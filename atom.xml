<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hevery&#39;s Utopia</title>
  
  <subtitle>库图佐夫虚弱又衰老，为何能打赢绝世统帅拿破仑？</subtitle>
  <link href="https://hevery.top/atom.xml" rel="self"/>
  
  <link href="https://hevery.top/"/>
  <updated>2021-11-08T02:58:50.618Z</updated>
  <id>https://hevery.top/</id>
  
  <author>
    <name>hevery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK11 线程池源码分析（上）</title>
    <link href="https://hevery.top/posts/24631506/"/>
    <id>https://hevery.top/posts/24631506/</id>
    <published>2021-11-07T14:00:00.000Z</published>
    <updated>2021-11-08T02:58:50.618Z</updated>
    
    <content type="html"><![CDATA[<p>#前言</p><blockquote><p>本源码系列均为JDK11版本，写文章之前曾对比过JDK11与JDK8版本之间的差异，总的来说，核心逻辑变化不大，但JDK11相比之前的JDK8，变量命名更加规范、代码更加简练、优化了很多糟糕的判断逻辑、方法抽象更加模块化。当然读者也可以将JDK11和JDK8配合使用，感受一下代码重构之美！<br><a href="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635998035633-eeb688db-2107-4282-a3ea-3ef4b38b139c.png">image.png</a>。</p></blockquote><blockquote><p>线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的的内存空间。在线程销毁时需要回收这些系统资源。<br>线程池的作用：</p><ul><li>使用池化技术管理并复用线程、控制最大并发数。</li><li>实现任务线程队列的缓存策略和拒绝机制。</li><li>利用某些与时间相关的功能，比如定时执行、周期执行。</li><li>隔离线程环境，不同的服务配置不同的线程池，避免相互影响。</li></ul></blockquote><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/wang-meng/p/12945703.html">https://www.cnblogs.com/wang-meng/p/12945703.html</a>  &lt;—- 基于JDK8，是我目前看过最牛逼的线程池源码解析<br><a href="https://juejin.cn/post/6844903494621773832#heading-1">https://juejin.cn/post/6844903494621773832#heading-1</a>&lt;—- 基于JDK8，比较全<br><a href="https://segmentfault.com/a/1190000023546243">https://segmentfault.com/a/1190000023546243</a> &lt;—- 基于JDK11，算是比较新了，但是有几处错误需注意</p></blockquote><h1 id="一、总体设计"><a href="#一、总体设计" class="headerlink" title="一、总体设计"></a>一、总体设计</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662135442-1518e558-6eea-46d0-972e-784f5301d3b9.png" alt="image.png"></p><p>类关系说明图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662467701-8f842874-7606-4e0c-9eae-17c8d5b0a60d.png" alt="image.png">：继承关系<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662651966-21e5dde9-cb27-417d-8f72-51dd88c67a80.png" alt="image.png">：实现关系<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662525013-8b913fcd-0d60-4e3d-9128-9c8223e1877c.png" alt="image.png">：依赖关系(作为参数或返回值)</p><blockquote><p>线程池的设计本质上和JDK中的集合框架、AQS设计一样，都是使用<strong>模板方法设计模式</strong>。<code>ExecutorService</code>接口继承了<code>Executor</code>接口，定义了管理线程任务的方法，<code>AbstractExecutorService</code>抽象类实现了<code>ExecutorService</code>接口，并提供了<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code>等部分方法的实现。但是核心方法<code>Executor.execute()</code>交由子类<code>ThreadPoolExecutor</code>和<code>ForkJoinPool</code>来分别实现。<code>Executors</code>工具类的静态工厂方法可以创建<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code>等线程池的包装对象。</p></blockquote><h1 id="二、Executor"><a href="#二、Executor" class="headerlink" title="二、Executor"></a>二、Executor</h1><blockquote><p><code>Executor</code>接口的设计思想是将任务的创建和任务的执行进行解耦，使用者只需制定任务的执行逻辑(Runnable)，无需关心任务在线程池中是如何被调度的以及线程创建和销毁。</p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669110622-2d22086e-718d-4c12-be90-e332be3f417c.png" width="35%" height="35%"/></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 提交任务给执行器，由执行器负责去执行任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、ExecutorService"><a href="#三、ExecutorService" class="headerlink" title="三、ExecutorService"></a>三、ExecutorService</h1><blockquote><ul><li><p>扩充Executor能力：可以提交一个或多个任务，获取任务的执行结果</p></li><li><p>提供管理线程任务的方法：终止线程池的运行，回收资源</p>  <img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669136644-d0a7ee89-e513-4f31-9196-056e1a82da3b.png" width="75%" height="75%"/></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，尝试停止所有正在执行的任务，停止等待任务的处理，并且返回等待执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断线程池是否已关闭(不对外接受任务，相当店里于打烊了，里面还在收拾东西)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断线程池是否终止(店里关灯了，收拾完了)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一段时间，如果到超时了，还没有terminated则返回false，反之则线程池已经terminated，返回true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个有返回值的任务，返回一个表示该任务挂起结果的Future，</span></span><br><span class="line">    <span class="comment">// 可使用Future的get方法获取任务成功完成时的返回结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上，result可以接受返回结果，</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个无返回值的任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有任务，返回一个 Future 类型的 List</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上，但设置了超时时间</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要一个任务结束了，就可以返回该任务的执行结果</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同上，但设置了超时时间</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="四、AbstractExecutorService"><a href="#四、AbstractExecutorService" class="headerlink" title="四、AbstractExecutorService"></a>四、AbstractExecutorService</h1><blockquote><p><code>AbstractExecutorService</code>实现了 <code>submit()</code>、<code>invokeAny()</code> 和 <code>invokeAll()</code> 方法(<strong>利用模板方法设计模式</strong>)，但它们只是在方法内部调用了<code>execute</code>方法，需要等具体执行器来实现这个最重要的部分，私有方法<code>newTaskFor()</code>将<code>Runnable</code>包装为<code>FutureTask</code>。定义于最上层接口 Executor中的<code>void execute(Runnable command)</code>由于不需要获取结果，不会进行 <code>FutureTask</code> 的包装。需要获取结果<code>FutureTask</code>，用 <code>submit()</code> 方法，不需要获取结果，可以用 <code>execute()</code> 方法。</p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669315780-7e3fa7a4-938d-42f8-bdaa-3e6459423835.png" width="75%" height="75%"/></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Runnable包装为FutureTask，用于submit调用</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Callable包装为FutureTask，用于submit调用</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务，使用了模板方法设计模式</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1.将任务包装成FutureTask</span></span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 2.交给执行器执行，具体执行逻辑由子类实现</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务，带返回结果</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1.将任务包装成FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        <span class="comment">// 2.交给执行器执行，具体执行逻辑由子类实现</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 提交任务，带返回结果</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 1.将任务包装成FutureTask</span></span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        <span class="comment">// 2.交给执行器执行，具体执行逻辑由子类实现</span></span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke：调用、激活</span></span><br><span class="line">    <span class="comment">// 将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span></span><br><span class="line">    <span class="comment">// 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span></span><br><span class="line">    <span class="comment">// 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">        <span class="comment">// 初始化ExecutorCompletionService，this作为其内部的执行器</span></span><br><span class="line">        <span class="comment">// ExecutorCompletionService使我们可以按任务的完成顺序从中取出对应的Future</span></span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">            <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For efficiency, especially in executors with limited</span></span><br><span class="line">        <span class="comment">// parallelism, check to see if previously submitted tasks are</span></span><br><span class="line">        <span class="comment">// done before submitting more of them. This interleaving</span></span><br><span class="line">        <span class="comment">// plus the exception mechanics account for messiness of main</span></span><br><span class="line">        <span class="comment">// loop.</span></span><br><span class="line"><span class="comment">// 为了更高效的利用执行器(有限的并行度)，在提交更多任务之前检查之前已经提交的</span></span><br><span class="line">        <span class="comment">// 任务是否已经完成。这个错综复杂的逻辑再加上异常处理机制可能导致了下面for循环的复杂度</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Record exceptions so that if we fail to obtain any</span></span><br><span class="line">            <span class="comment">// result, we can throw the last exception we got.</span></span><br><span class="line">            <span class="comment">// 记录异常，如果我们得到任何有效结果，我们可以抛出最后一个得到的异常</span></span><br><span class="line">            ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先提交一个任务，后续任务到下面的for循环中一个一个提交</span></span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            <span class="comment">// 上面提交了一个任务，所以任务数减 1</span></span><br><span class="line">            --ntasks;</span><br><span class="line">            <span class="comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span></span><br><span class="line">            <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 以非阻塞的方式获取一个任务的执行结果 Future</span></span><br><span class="line">                Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">                <span class="comment">// Future 获取失败</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 提交下一个任务</span></span><br><span class="line">                    <span class="comment">// 假设一个任务执行时间很长(一个也没获取到)，那么只好先把所有的任务先提交</span></span><br><span class="line">                    <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                 </span><br><span class="line">                    <span class="comment">// 此处应用场景：因为break退出循环之后，必然会抛出异常ee，所以此处的发生应该是在</span></span><br><span class="line">                    <span class="comment">// 下面执行return f.get()时发生了异常，而此处正是该异常的一个出口，跳出for循环后</span></span><br><span class="line">                    <span class="comment">// 会调用throw ee 抛出</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 这里是else if，说明ntask &lt;= 0，即已经提交完所有的任务，但是还没有获取到一个任务</span></span><br><span class="line">                    <span class="comment">// 如果设置了获取任务的超时时间，那么将尝试在nanos时间内获取一个任务的执行结果</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        <span class="comment">// 超时的话抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                        nanos = deadline - System.nanoTime();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果已经提交完所有任务也没有设置超时时间，</span></span><br><span class="line">                    <span class="comment">// 那么就尝试以阻塞的方式获取一个任务的执行结果</span></span><br><span class="line">                    <span class="comment">// 这个时候会一直等，直到获取到一个任务的执行结果</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        f = ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Future 获取成功</span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 正在执行的任务数 -1</span></span><br><span class="line">                    --active;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 返回执行结果，如果有异常，都包装成ExecutionException</span></span><br><span class="line">                        <span class="keyword">return</span> f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                        ee = eex;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                        ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">                ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">            <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 方法退出之前，取消其他任务，</span></span><br><span class="line">            <span class="comment">// 不会取消已完成的任务(对于已完成的任务，取消没有什么效果)</span></span><br><span class="line">            cancelAll(futures);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带超时时间的 invokeAny</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时时间的 invokeAny</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有的任务，返回任务结果</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 包含所有任务执行结果的 Future 列表</span></span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                <span class="comment">// 包装成 FutureTask</span></span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                <span class="comment">// 提交任务</span></span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span></span><br><span class="line">                        <span class="comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span></span><br><span class="line">                        <span class="comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span></span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (CancellationException | ExecutionException ignore) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来</span></span><br><span class="line">            <span class="comment">// 这个方法返回是包含所有任务执行结果的 Future 列表</span></span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 发生异常，取消所有的 Future</span></span><br><span class="line">            cancelAll(futures);</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时的 invokeAll</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="comment">// 截止时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        timeOut:<span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">            <span class="comment">// executor doesn&#x27;t have any/much parallelism.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((i == <span class="number">0</span>) ? nanos : deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">// 如果提交任务时就超时，直接break</span></span><br><span class="line">                    <span class="keyword">break</span> timedOut;</span><br><span class="line">                <span class="comment">// 提交任务</span></span><br><span class="line">                execute((Runnable)futures.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 获取完成的任务</span></span><br><span class="line">            <span class="keyword">for</span> (; j &lt; size; j++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(j);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; f.get(deadline - System.nanoTime(), NANOSECONDS); &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (CancellationException | ExecutionException ignore) &#123;&#125;</span><br><span class="line">                    <span class="keyword">catch</span> (TimeoutException timedOut) &#123;</span><br><span class="line">                        <span class="comment">// 某个任务获取超时了，就 break</span></span><br><span class="line">                        <span class="keyword">break</span> timedOut;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里应该是超时 break 了，所以取消还没有完成的 Future</span></span><br><span class="line">        cancelAll(futures, j);</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消所有的 Future</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(ArrayList&lt;Future&lt;T&gt;&gt; futures)</span> </span>&#123;</span><br><span class="line">        cancelAll(futures, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消索引 j 之后所有的 Future</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">cancelAll</span><span class="params">(ArrayList&lt;Future&lt;T&gt;&gt; futures, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> size = futures.size(); j &lt; size; j++)</span><br><span class="line">            futures.get(j).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::success<br><strong>番外篇：Runnable在执行时也是通过适配器模式被包装成Callable。</strong><br><strong>看如下解释：</strong><br>:::</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上面代码的其中一小段(将Runnable包装为FutureTask，用于submit调用)</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Executors工具类的静态工厂callable方法</span></span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 将Runnable包装成一个向Callable转化的适配器RunnableAdapter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器设计模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable task;</span><br><span class="line">        <span class="keyword">final</span> T result;</span><br><span class="line">        RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.result = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            task.run();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#前言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本源码系列均为JDK11版本，写文章之前曾对比过JDK11与JDK8版本之间的差异，总的来说，核心逻辑变化不大，但JDK11相比之前的JDK8，变量命名更加规范、代码更加简练、优化了很多糟糕的判断逻辑、方法抽象更加模块化。当然</summary>
      
    
    
    
    <category term="Java" scheme="https://hevery.top/categories/Java/"/>
    
    
    <category term="JUC" scheme="https://hevery.top/tags/JUC/"/>
    
    <category term="线程池" scheme="https://hevery.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDK11 线程池源码分析 （下）</title>
    <link href="https://hevery.top/posts/24631506/"/>
    <id>https://hevery.top/posts/24631506/</id>
    <published>2021-11-07T14:00:00.000Z</published>
    <updated>2021-11-08T02:58:50.623Z</updated>
    
    <content type="html"><![CDATA[<p>#六.这些面试问题会答了吗？<br>##1.Java线程池是如何保证核心线程不被销毁的？<br>##2.Java线程池中多余的线程是如何回收的？<br>##3.ThreadPoolExecutor中创建的线程如何被复用的？<br>##4.线程池如何按照core、max、queue的执行循序去执行？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#六.这些面试问题会答了吗？&lt;br&gt;##1.Java线程池是如何保证核心线程不被销毁的？&lt;br&gt;##2.Java线程池中多余的线程是如何回收的？&lt;br&gt;##3.ThreadPoolExecutor中创建的线程如何被复用的？&lt;br&gt;##4.线程池如何按照core、max、qu</summary>
      
    
    
    
    <category term="Java" scheme="https://hevery.top/categories/Java/"/>
    
    
    <category term="JUC" scheme="https://hevery.top/tags/JUC/"/>
    
    <category term="线程池" scheme="https://hevery.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>JDK11 线程池源码分析（中）</title>
    <link href="https://hevery.top/posts/24631506/"/>
    <id>https://hevery.top/posts/24631506/</id>
    <published>2021-11-07T14:00:00.000Z</published>
    <updated>2021-11-08T02:58:50.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五、ThreadPoolExecutor"><a href="#五、ThreadPoolExecutor" class="headerlink" title="五、ThreadPoolExecutor"></a>五、ThreadPoolExecutor</h1><blockquote><p><code>ThreadPoolExecutor</code> 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等方法。<br>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的<code>ScheduledThreadPoolExecutor</code> 就继承自 <code>ThreadPoolExecutor</code>。<br>线程池是一种生产者-消费者模式，线程池的使用方式生产者，线程池本身是消费者。</p></blockquote><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635750405102-47c1b067-ab23-4887-af79-ff574c6bda91.png" width="75%" height="75%" /><p><strong>写在前面</strong>：很多人认为线程池的源码复杂，其实核心逻辑就是上面这幅图展示的，它的复杂在于需要随时随地对线程池的状态进行判断、对线程池中线程数量进行判断、对任务队列是否为空进行判断等等，因为线程池通常是被多个线程同时调用的，很有可能其中某个线程进行了<code>shutdown()</code>、<code>shutdownNow()</code>等操作，甚至在线程池运行期间通过<code>setCorePoolSize()</code>、<code>setMaximumPoolSize()</code>、<code>setKeepAliveTime()</code>、<code>allowsCoreThreadTimeOut()</code>等方法动态调整参数，而这些都是需要线程池”<strong>时刻提防</strong>“的，所以才有了看起来很复杂的判断逻辑，当我们在遇到它们的时候，如果带着上面的思考再去考虑可能遇到的各种情况，或许就豁然开朗了。还有一点，在代码的关键部分保留了英文注释，可以结合着讲解一些看，它是我们读懂作者设计思路的一手资源。</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">// 最大线程数，线程池允许创建的最大线程数</span></span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 非核心线程获取任务时的等待时间，超时后就会被销毁</span></span><br><span class="line">    <span class="comment">// 当然，也可以通过调用 allowCoreThreadTimeOut(true) 使核心线程数内的线程也可以被回收。</span></span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="comment">// 线程工厂，它用来生产一组相同任务的线程，线程池的命名是通过给这个 factory 增加组名前缀来实现的。</span></span><br><span class="line">    <span class="comment">// 在虚拟机栈分析时，就可以知道线程任务是有哪个线程工厂生产的。</span></span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的构造方法是<code>ThreadPoolExecutor</code>中最全的一个构造方法。这里我们重点说一下<code>threadFactory</code>这个参数。<br>如果在构造函数中不传<code>threadFactory</code>，默认使用的是<code>Executors.defaultThreadFactory()</code>，实现如下，我们在实际应用中通常需要根据自己的业务，重新定义线程工厂，为线程指定有意义的名称和序列号。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executors</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态工厂方法，返回线程池默认的线程工厂实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">        DefaultThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">            Thread.currentThread().getThreadGroup();</span><br><span class="line">            namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                poolNumber.getAndIncrement() +</span><br><span class="line">                <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                  namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                  <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">                t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">                t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>RejectedExecutionHandler</code>表示拒绝策略，它的执行时机是当阻塞队列已满且没有空闲的线程(包括核心和非核心)时对新提交过来的任务的执行策略。<code>ThreadPoolExecutor</code>内部实现了四种拒绝策略，它们是四个公共的静态内部类，都实现了<code>RejectedExecutionHandler</code>这个接口。由于内建的这几种策略都有各自的局限性，所以我们在工作中一般会制定自己的拒绝策略。下面我们看一下内建的四种拒绝策略：</p></blockquote><ul><li>AbortPolicy：默认的拒绝策略，直接抛出异常</li><li>DiscardPolicy：忽略提交的任务(里面是个空实现)</li><li>DiscardOldestPolicy：抛弃最老的任务，通过<code>poll()</code>方法取出任务队列队头的任务抛弃，然后提交当期任务</li><li>CallerRunsPolicy：让调用者线程执行当前被拒绝任务，这样原来的异步调用会退化为同步调用，所以我们一般不推荐这么做。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认的拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略任务 do nothing</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 抛弃队头任务，提交当前任务</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让当前调用Executor#execute()的线程直接调用任务Runnable#run()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-线程池状态"><a href="#2-线程池状态" class="headerlink" title="2.线程池状态"></a>2.线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctl存储线程池状态和线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// Integer 共有 32 位，低 29 位表示工作线程数，高 3 位表示线程池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 最大线程数 000-11111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">// 这里得到 29 个 1，用法类似于子网掩码，用于位与运算</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_MASK   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1的补码(32个1)： 111-11111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">// 所以左移32位结果： 111-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="comment">// 此状态表示线程池能够接受新任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CAPACITY 按位取反，高 3 变为 1，低 29 位变为 0</span></span><br><span class="line"><span class="comment">// 比如： 001-00000 00000000 00000000 00000011 表示当前有3个线程</span></span><br><span class="line"><span class="comment">// ~CAPACITY: 111-00000 00000000 00000000 00000000</span></span><br><span class="line"><span class="comment">// 按位与后:   001-00000 00000000 00000000 00000000 表示线程池处于 stop 状态</span></span><br><span class="line"><span class="comment">// 获取当前线程池的状态(高3位)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~COUNT_MASK; &#125;</span><br><span class="line"><span class="comment">// 获取线程池中的线程数(低29位)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; COUNT_MASK; &#125;</span><br><span class="line"><span class="comment">// 上面的操作的反向：根据运行状态和线程数获取 ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面三个方法都是通过 ctl 来判断线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateLessThan</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">runStateAtLeast</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 CAS 使线程数 +1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndIncrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过 CAS 增加线程数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndDecrementWorkerCount</span><span class="params">(<span class="keyword">int</span> expect)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Decrements the workerCount field of ctl. This is called only on</span></span><br><span class="line"><span class="comment">  * abrupt termination of a thread (see processWorkerExit). Other</span></span><br><span class="line"><span class="comment">  * decrements are performed within getTask.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">// 线程数直接 -1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decrementWorkerCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ctl.addAndGet(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里重点说一下<code>compareAndDecrementWorkerCount()</code>和<code>decrementWorkerCount()</code>的区别：<br><code>decrementWorkerCount</code>在JDK8中中是这样实现的：<br>private void decrementWorkerCount() {<br>    do {} while (! compareAndDecrementWorkerCount(ctl.get()));<br>}<br>前者会通过返回值来判断线程数 -1 操作是否成功(可能会失败)，而后者是循环直到你  -1 成功！<br>线程池五种状态的十进制从小到大排序依次为：<strong>RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</strong>。</p></blockquote><ul><li>RUNNING：表示正常的状态，接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有任务都销毁了，线程数为0，会执行钩子方法 <code>terminated()</code></li><li>TERMINATED：执行钩子方法 <code>terminated()</code>完毕，线程池彻底关闭</li></ul><blockquote><p>线程池状态轮转图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635989873122-690788e3-0f30-4b45-a06d-9b60765badc1.png" alt="image.png"></p></blockquote><h2 id="3-execute方法"><a href="#3-execute方法" class="headerlink" title="3.execute方法"></a>3.execute方法</h2><blockquote><p><code>execute()</code>方法是<code>ThreadPoolExecutor</code>的<strong>核心逻辑</strong>，主要负责任务的调度。<br>​<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635826704184-37025c80-6c8c-4389-8134-c59a73ca4e23.png" alt="image.png"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn&#x27;t, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="comment">// 获取ctl的值(之前说的那个表示 &quot;线程池状态&quot; 和 &quot;线程数&quot; 的整数)</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果线程数小于核心线程数，则创建新的核心线程并执行传入的任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="comment">// 创建成功则返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 创建失败，更新 ctl 的临时变量 c</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里两种情况：</span></span><br><span class="line">    <span class="comment">// 1.线程数 &gt;= 核心线程数</span></span><br><span class="line">    <span class="comment">// 2.addWorker 返回 false (线程池状态非 RUNNING)</span></span><br><span class="line">    <span class="comment">// 所以如果线程池此时处于 RUNNING 状态(针对情况 1 )，则将任务加入任务队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// double-check，重新获取线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池此时变为非 RUNNING 状态，则从任务队列中删除任务(roll back)</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 执行拒绝策略处理任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 走到这里有两种情况：</span></span><br><span class="line">        <span class="comment">// 1.线程池处于 RUNNING 状态，线程数 &gt;= 核心线程数</span></span><br><span class="line">        <span class="comment">// 2.线程池处于非 RUNNING 状态，但是上面 remove 失败，</span></span><br><span class="line">        <span class="comment">// 失败的原因可能是任务在 remove 之前已经出队被执行，这种情况我们无需关心</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 对于 RUNNING ，如果当前线程数量为 0，则创建一个非核心线程并且传入的任务对象为 null，</span></span><br><span class="line">            <span class="comment">// 这里传入 null 是是因为任务已经在任务队列中</span></span><br><span class="line">            <span class="comment">// 所以这块代码的真正意图是：担心任务提交到任务队列中了，但是此时线程数为0(可能设置了allowCoreThreadTimeOut=true)</span></span><br><span class="line">            <span class="comment">// 那必须有一个线程来执行任务，可以理解为一种兜底机制</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 最后的else分支(假设有，哈哈)对应的情况，线程数不为 0，任务也已经成功入队，所以什么也不用做</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走到这里两种情况：</span></span><br><span class="line">    <span class="comment">// 1.线程池处于非 RUNNING 状态，这时调用 addWorker 肯定返回 false</span></span><br><span class="line">    <span class="comment">// 2.线程池处于 RUNNING 状态，线程数 &gt;= 核心线程数，且任务队列已满，这时需要创建非核心线程来执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 新增失败则执行拒绝策略处理任务</span></span><br><span class="line">        <span class="comment">// 失败原因：1.线程池处于非 RUNNING 状态 2.线程数超过最大线程数 maximumPoolSize</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从任务队列中移除当前任务 task</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = workQueue.remove(task);</span><br><span class="line">    <span class="comment">// 因为调用此方法时线程池处于非运行状态，所以会尝试关闭线程线程池</span></span><br><span class="line">    tryTerminate(); <span class="comment">// In case SHUTDOWN and now empty</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里比较难理解的是<strong>为什么要double-check?</strong><br>特意没有删了上面的英文注释，对照着我们来简单看一下第二点：<br>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结(<code>workerCountOf(recheck) == 0</code>）或者执行当前方法(<code>workQueue.offer(command)</code>)的时候线程池已经shut down了(<code>! isRunning(recheck)</code>)。所以我们需要二次检查线程池的状态，必要时<strong>把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程(对应</strong><code>if (! isRunning(recheck) &amp;&amp; remove(command))</code><strong>和</strong><code>else if (workerCountOf(recheck) == 0)</code>**两个分支)**。</p></blockquote><h2 id="4-addWorker"><a href="#4-addWorker" class="headerlink" title="4.addWorker"></a>4.addWorker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数：firstTask 为每个 Worker 新建时处理的第一个任务，无需从任务队列中取，</span></span><br><span class="line"><span class="comment">//处理完第一个任务后 Worker 后续会通过 getTask() 方法从任务队列取任务执行</span></span><br><span class="line"><span class="comment">// 参数：core 表示是否创建核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 响应下文的 continue retry，快速退出多层嵌套循环</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = ctl.get();;) &#123;</span><br><span class="line">        <span class="comment">// runStateAtLeast(c, SHUTDOWN)：为了快速短路，线程池为 RUNNING 的话就不需要执行后面的判断</span></span><br><span class="line">        <span class="comment">// (runStateAtLeast(c, STOP) || firstTask != null || workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 1.STOP 即以上状态 ----&gt;都快打扫完了就别添乱了</span></span><br><span class="line">        <span class="comment">// 2.SHUTDOWN 状态且 firstTask 不为空  ----&gt; 打烊了不接新客了</span></span><br><span class="line">        <span class="comment">// 3.SHUTDOWN 状态且 firstTask 为空且任务队列为空 -----&gt; 打烊了门口也没新客了店里的人也走完了</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP)</span><br><span class="line">                || firstTask != <span class="keyword">null</span></span><br><span class="line">                || workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 走到这里两种情况：</span></span><br><span class="line">        <span class="comment">// 1.线程池为 RUNNING 状态</span></span><br><span class="line">        <span class="comment">// 2.线程池为 SHUTDOWN 状态，提交任务firstTask为空，任务队列不为空，即 addWorker(null, false)</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 1.创建的是核心线程且线程数量 &gt;= 设定的核心线程数 </span></span><br><span class="line">            <span class="comment">// 2.创建的事非核心线程且线程数量 &gt;= 设定的最大线程数 </span></span><br><span class="line">            <span class="comment">// 以上两种情况均 return false</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c)</span><br><span class="line">                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 走到这里说明可以创建线程了，CAS 操作线程数量 +1，成功 跳出循环执行后面语句 </span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get(); </span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">           <span class="comment">// 所以这里判断只要线程池不是 RUNNING 状态，就回到最外层循环重新执行</span></span><br><span class="line">            <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN))</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// 走到这说明是 CAS 失败，存在多个线程同时执行 workCount+1，</span></span><br><span class="line">            <span class="comment">// 所以只需内部自旋，直到每个线程都 workCount+1 成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里，我们认为当前这个时刻，可以开始创建线程来执行任务了</span></span><br><span class="line">    <span class="comment">// 表示 worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 表示 worker 是否创建成功</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="comment">// 这里判断t != null是因为用户可以自定义ThreadFactory，</span></span><br><span class="line">        <span class="comment">// 如果这里用户直接返回null或者因为一些谜之操作创建失败了都应该考虑到，所以需要判断一下</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里需要全局加锁，因为可能会并发修改一些线程池的指标值和hashset(worker 集合)</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 持有锁之后重新获取线程池状态，因为可能在获取锁的过程状态被其他线程更改</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据逻辑或的短路原则，这里有两种情况：</span></span><br><span class="line">                <span class="comment">// 1.线程池状态为RUNNING</span></span><br><span class="line">                <span class="comment">// 2.线程池状态为SHUTDOWN，并且传入的任务实例 firstTask 为 null，</span></span><br><span class="line">                <span class="comment">//   因为在SHUTDOWN状态时不会再添加新的任务，但是可以继续处理workQueue中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 此时线程的状态为新建但没有启动，否则抛出异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.getState() != Thread.State.NEW)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 把新建的 worker 加入到 workers 集合中 </span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// 更改线程池的峰值容量(历史的最大容量)</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 线程启动失败，需要从 workers 集合移除对应的 worker</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回滚创建的worker</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 从 workers 集合中移除启动失败的 worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// 工作线程数量 -1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 基于状态判断尝试终结线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Worker"><a href="#6-Worker" class="headerlink" title="6.Worker"></a>6.Worker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 ThreadFactory 创建的线程实例，如果 ThreadFactory 创建失败则为 null</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">// 保存 Runnable 任务实例</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">// 记录每个线程完成的任务总数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，传入任务实例 firstTask，可以为 null</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        <span class="comment">// 禁止线程中断，直到 runWorker() 方法运行，看后面 interruptIfStarted() 方法的实现</span></span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 通过 ThreadFactory 创建线程实例，注意一下 Worker 实例自身作为 Runnable 用于创建新的线程 </span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托到外部的 runWorker() 方法，注意 runWorker() 是线程池的方法，不是 Worker 的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">    <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"><span class="comment">// 是否持有独占锁，state 值为 1 的时候表示持有锁，state 值为 0 的时候表示释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占模式下尝试获取资源，这里没有判断传入的变量，直接 CAS 判断 0 更新为 1 是否成功，</span></span><br><span class="line">    <span class="comment">// 成功则设置独占线程为当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 独占模式下尝试释放资源，这里没有判断传入的变量，直接把 state 设置为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 尝试加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">// 当前 worker 是否被锁定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程启动后进行中断</span></span><br><span class="line">    <span class="comment">// 中断条件：线程已经启动，并且中断标志位为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::info<br><code>Worker</code> 继承自 AQS，这里使用了 AQS 的独占模式，构造<code>Worker</code>的时候，把AQS的资源（状态）通过<code>setState(-1)</code>设置为 -1，这是因为<code>Worker</code>实例刚创建时AQS中<code>state</code>的默认值为0，此时线程尚未启动，不能在这个时候进行线程中断，见Worker#interruptIfStarted()方法。<br>:::</p><h2 id="7-runWorker"><a href="#7-runWorker" class="headerlink" title="7.runWorker"></a>7.runWorker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程，实际上和 Worker 持有的线程实例是相同的</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取 Worker 持有的任务对象，存放在临时变量 task 中</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 由于 Worker 初始化时 AQS 中 state 值为 -1，这里要先做一次解锁把 state 置为0，允许线程中断</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">// 记录线程是否因用户异常终结，默认 true</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 任务对象不为 null，或者从任务队列获取任务不为空，</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="comment">// 如果线程池正在停止，那么要确保当期那工作线程是中断状态，否则，要确保当前线程不是中断状态</span></span><br><span class="line">            <span class="comment">// 两种情况：</span></span><br><span class="line">            <span class="comment">// 1.当前线程池状态 &gt;= STOP</span></span><br><span class="line">            <span class="comment">// 2.当前线程目前是已中断的状态 并且线程池的状态也是 &gt;= Stop 的</span></span><br><span class="line">            <span class="comment">// 注意 Thread.interrupted是会擦除中断标识符的，所以 !wt.isInterrupted() 一定返回 true</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，任务执行前</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 正常情况</span></span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，任务执行后 - 异常情况</span></span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 清空 task，准备 getTask 获取下一个任务</span></span><br><span class="line">                <span class="comment">// 这个很重要，否则 while 会死循环执行同一个 task</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 累计该 Worker 完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// Worker 解锁，本质是 AQS 释放资源，设置 state 为 0 </span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 走到这里，说明 Worker 的一生要结束了：</span></span><br><span class="line">        <span class="comment">// 1.正常结束，completedAbruptly 为false，getTask 返回为 null，没任务可执行了</span></span><br><span class="line">        <span class="comment">// 2.异常结束，completedAbruptly 为true，throw ex 中抛出了异常</span></span><br><span class="line">        <span class="comment">// completedAbruptly为true说明task.run()出现了异常</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Thread.interrupted()</code>方法用于获取调用方线程的中断状态同时会清空该中断状态，这里之所以会调用这个方法是因为在执行上面这个if逻辑同时外部有可能调用<code>shutdownNow()</code>方法，<code>shutdownNow()</code>方法中也存在中断所有<code>Worker</code>线程的逻辑，但是由于<code>shutdownNow()</code>方法中会遍历所有<code>Worker</code>做线程中断，有可能无法及时在任务提交到<code>Worker</code>执行之前进行中断，所以这个中断逻辑会在<code>Worker</code>内部执行，就是if代码块的逻辑。这里还要注意的是：<code>STOP</code>状态下会拒绝所有新提交的任务，不会再执行任务队列中的任务，同时会中断所有<code>Worker</code>线程。也就是，即使任务<code>Runnable</code>已经在<code>runWorker()中</code>前半段逻辑取出，只要还没走到调用其<code>Runnable#run()</code>，都有可能被中断。假设刚好发生了进入if代码块的逻辑同时外部调用了<code>shutdownNow()</code>方法，那么if逻辑内会判断线程中断状态并且重置，那么<code>shutdownNow()</code>方法中调用的<code>interruptWorkers()</code>就不会因为中断状态判断出现问题导致二次中断线程（会导致异常）。</p></blockquote><h2 id="8-getTask"><a href="#8-getTask" class="headerlink" title="8.getTask"></a>8.getTask</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上次从任务队列中 poll 是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.线程池状态 &gt;= STOP ，runStateAtLeast(c, SHUTDOWN) &amp;&amp; runStateAtLeast(c, STOP)</span></span><br><span class="line">        <span class="comment">// 2.线程池状态 == SHUTDOWN &amp;&amp; workQueue.isEmpty()，runStateAtLeast(c, SHUTDOWN) &amp;&amp; !runStateAtLeast(c, STOP) &amp;&amp; workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 上面的分析其实是剖开了揉碎了来分析很不利于理解，所以大可不必那样</span></span><br><span class="line">        <span class="comment">// 在我看来这还是一种快速失败机制，因为线程池在正常情况下都是 RUNNING 状态，所以这里第一条件都不符合</span></span><br><span class="line">        <span class="comment">// 只有当线程池是 SHUTDOWN 的时候，才进一步判断是要变为 STOP(不处理任务队列中的任务) </span></span><br><span class="line">        <span class="comment">// 还是 任务队列为空(没任务可处理)，故返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (runStateAtLeast(c, SHUTDOWN)</span><br><span class="line">            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 无论如何都要让线程数 -1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="comment">// 判断 worker 是否需要被剔除</span></span><br><span class="line">        <span class="comment">// 外部如果调用了 allowCoreThreadTimeOut(true)：允许核心线程也使用 keepAliveTime</span></span><br><span class="line">        <span class="comment">// 那么如果允许核心线程数内的线程回收，或工作线程数超过了核心线程数，都有可能发生超时关闭</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个条件：工作线程数大于最大线程数或者线程已经超时</span></span><br><span class="line">        <span class="comment">// 第二个条件：存活线程数不止一个或者任务队列空了</span></span><br><span class="line">        <span class="comment">// 同时满足上面两个条件：线程数 -1，不返回任务</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 走到这里说明 wc &lt;= maximumPoolSize 并且没有超时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// timed 为 true：限时等待提取任务队列中的任务(非核心线程或设置了允许超时的核心线程)，超时返回 null</span></span><br><span class="line">            <span class="comment">// timed 为 false：阻塞等待提取任务队列中的任务(核心线程才会阻塞)</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// r == null 说明已超时</span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getTask()</code>主用于从阻塞队列中获取任务，如果当前线程小于核心线程，那么当阻塞队列中没有任务时就会阻塞，反之会等待<code>keepAliveTime</code>后返回。<br>此处再理解<code>keepAliveTime</code>的使用含义：非核心线程等待新任务的时间，超时的话<code>getTask()</code>方法就会返回<code>null</code>，<code>runWorker()</code>就会执行<code>processWorkerExit()</code>尝试去清理空闲的线程(此时worker的state 等于 0)。</p></blockquote><h2 id="9-processWorkerExit"><a href="#9-processWorkerExit" class="headerlink" title="9.processWorkerExit"></a>9.processWorkerExit</h2><blockquote><p>走到<code>processWorkerExit()</code>这个方法时，有两种情况：一种是<code>runWorker()</code>中调用<code>getTask()</code>返回<code>null</code>(线程池要<code>SHUTDOWN</code>或者非核心线程超时了)，另一种是<code>runWorker()</code>中执行任务发生异常了。这时需要终止这个<code>Worker</code>，所以才会调用这个方法。<br><strong>启示：</strong><code>task#run()</code>里最好是把所有的异常捕获 而不要抛出 不然抛出异常 就会立刻销毁线程 然后创建一个新线程 线程池的作用就没有。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// completedAbruptly 为 true：说明线程执行时出现异常</span></span><br><span class="line"><span class="comment">// completedAbruptly 为 false：说明 runWorker 由于 getTask 返回 null 正常结束的，</span></span><br><span class="line"><span class="comment">// getTask方法中已经对 workerCount 进行减一</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 非正常结束没来记得及将 workerCount -1，所以此时需要 -1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 更新线程池已完成任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 从 workers 集合中移除该 worker</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 尝试关闭线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 线程池为 RUNNING 或 SHUTDOWN，如果不是这两个状态，说明线程已经停止了，啥都不会要干了</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 如果是正常结束</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="comment">// 如果允许核心线程超时并且当前队列里面还有任务没跑呢，那就必须留一个线程，不能全死掉.</span></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果线程池中线程的数量至少有 1 个，那没事了，至少能执行完任务队列中的任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 走到这里有三种情况</span></span><br><span class="line">        <span class="comment">// 1.worker 是因为某个异常 task 结束的，并不是我真正想结束，所以需要新增一个 worker</span></span><br><span class="line">        <span class="comment">// 2.任务队列里还有任务，但是核心线程都关了，这种情况下最起码要留一个线程(可能正在 SHUTDOWN)</span></span><br><span class="line">        <span class="comment">// 3.当前线程数量 &lt; corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个水平</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-tryTerminate"><a href="#10-tryTerminate" class="headerlink" title="10.tryTerminate"></a>10.tryTerminate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 1.线程池状态为 RUNNING</span></span><br><span class="line">        <span class="comment">// 2.线程池状态为 TIDYING，不需要你来关了</span></span><br><span class="line">        <span class="comment">// 3.线程池状态为 SHUTDOWN，但是任务队列还有任务，得等队列中的任务处理完毕后再关</span></span><br><span class="line">        <span class="comment">// 上面三种情况直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 走到这里两种情况</span></span><br><span class="line">        <span class="comment">// 1.线程池状态为 STOP</span></span><br><span class="line">        <span class="comment">// 2.线程池状态为 SHUTDOWN，但是任务队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">// 中断一个空闲的 worker</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 走到这里，说明workerCountOf(c) == 0，</span></span><br><span class="line">        <span class="comment">// 在调用 tryTerminate 之前，workerCount已经减为 0，表示这是最后一个退出的线程</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置线程池状态为 TIDYING，如果设置成功，则调用 terminated() 方法</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// terminated() 执行完毕之后设置状态为 TERMINATED</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">// 唤醒那些阻塞在 termination 上的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-interruptIdleWorker"><a href="#11-interruptIdleWorker" class="headerlink" title="11.interruptIdleWorker"></a>11.interruptIdleWorker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断空闲的 worker</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历 workers，根据 onlyOne 判断是中断一个 worker 还是所有</span></span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 线程没有被中断并且线程是空闲状态 tryLock() 判断是否空闲</span></span><br><span class="line">            <span class="comment">// 因为worker执行任务上会调用 w.lock()，这时再调用 tryLock() 返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>遍历<code>workers</code>，如果线程是空闲状态(空闲状态：<code>queue.take()</code>和<code>queue.poll()</code>返回空)，则给其一个中断信号，如果是处于<code>workQueue</code>阻塞的线程，会被唤醒，唤醒后，进入下一次自旋时，可能会<code>return null</code>执行退出相关的逻辑，接着又会调用<code>processWorkerExit()-&gt;tryTerminate()</code>，回到上面场景，当前线程退出的时候还是会继续唤醒下一个空现线程。</p></blockquote><h2 id="12-一些和关闭相关的方法"><a href="#12-一些和关闭相关的方法" class="headerlink" title="12.一些和关闭相关的方法"></a>12.一些和关闭相关的方法</h2><h3 id="1-awaitTermination"><a href="#1-awaitTermination" class="headerlink" title="1.awaitTermination"></a>1.awaitTermination</h3><blockquote><p>还记得上面的<code>tryTerminate()</code>方法中的<code>termination.signalAll()</code>，没错唤醒的就是调用<code>awaitTermination()</code>这个方法的线程。因为<code>awaitTermination()</code>这个方法支持超时，所以如果调用了该方法，并且在超时间内线程池状态还不是 <code>TERMINATED </code>，那么调用该方法的线程就会在条件变<code>private final _Condition _termination = mainLock.newCondition();</code>上等待，直到被中断或者超时。如果等待期间线程池状态变为<code>TERMINATED</code>，那么调用该方法的线程就可能会被唤醒，从而返回 <code>true</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (runStateLessThan(ctl.get(), TERMINATED)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = termination.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-shutdown"><a href="#2-shutdown" class="headerlink" title="2.shutdown"></a>2.shutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 安全检查：判断调用该方法的线程是否具有关闭线程池的权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// RUNNING -&gt; SHUTDOWN 状态转换</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 中断所有空闲线程，默认 onlyOne 为false</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        <span class="comment">// ScheduledThreadPoolExecutor 预留的钩子 </span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-shutdownNow"><a href="#3-shutdownNow" class="headerlink" title="3.shutdownNow"></a>3.shutdownNow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">// 中断所有线程，注意和 interruptIdleWorkers 的区别 </span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert mainLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">        w.interruptIfStarted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// 不管有没有获得锁 w.lock()，只要线程启动后(可能在执行任务也可能空闲)都可以被中断</span></span><br><span class="line">    <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-isShutdown"><a href="#4-isShutdown" class="headerlink" title="4.isShutdown"></a>4.isShutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池状态 &gt;= SHUTDOWN，注意并不只是等于</span></span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(ctl.get(), SHUTDOWN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-isTerminating"><a href="#5-isTerminating" class="headerlink" title="5.isTerminating"></a>5.isTerminating</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// SHUTDOWN =&lt; 线程池状态 &lt;= TERMINATED</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(c, SHUTDOWN) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-isTerminated"><a href="#6-isTerminated" class="headerlink" title="6.isTerminated"></a>6.isTerminated</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程池状态 &gt;= TERMINATED</span></span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13线程池的预热和动态调参"><a href="#13线程池的预热和动态调参" class="headerlink" title="13线程池的预热和动态调参"></a>13线程池的预热和动态调参</h2><h3 id="1-核心线程的预热功能"><a href="#1-核心线程的预热功能" class="headerlink" title="1.核心线程的预热功能"></a>1.核心线程的预热功能</h3><p>:::info<br>核心线程启动后可能任务队列为空，此时会阻塞在任务队列上直到有任务进来。<br>:::</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动一个核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动所有核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>))</span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动态调整线程池参数"><a href="#2-动态调整线程池参数" class="headerlink" title="2.动态调整线程池参数"></a>2.动态调整线程池参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCorePoolSize</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">int</span> delta = corePoolSize - <span class="keyword">this</span>.corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We don&#x27;t really know how many new threads are &quot;needed&quot;.</span></span><br><span class="line">        <span class="comment">// As a heuristic, prestart enough new workers (up to new</span></span><br><span class="line">        <span class="comment">// core size) to handle the current number of tasks in</span></span><br><span class="line">        <span class="comment">// queue, but stop if queue becomes empty while doing so.</span></span><br><span class="line">        <span class="keyword">int</span> k = Math.min(delta, workQueue.size());</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workQueue.isEmpty())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allowCoreThreadTimeOut</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Core threads must have nonzero keep alive times&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class="line">        allowCoreThreadTimeOut = value;</span><br><span class="line">        <span class="keyword">if</span> (value)</span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeepAliveTime</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span> &amp;&amp; allowsCoreThreadTimeOut())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Core threads must have nonzero keep alive times&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> keepAliveTime = unit.toNanos(time);</span><br><span class="line">    <span class="keyword">long</span> delta = keepAliveTime - <span class="keyword">this</span>.keepAliveTime;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = keepAliveTime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-线程池的一些其他参数"><a href="#3-线程池的一些其他参数" class="headerlink" title="3.线程池的一些其他参数"></a>3.线程池的一些其他参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池中线程的数量(包含活跃线程和空闲线程)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Remove rare and surprising possibility of</span></span><br><span class="line">        <span class="comment">// isTerminated() &amp;&amp; getPoolSize() &gt; 0</span></span><br><span class="line">        <span class="keyword">return</span> runStateAtLeast(ctl.get(), TIDYING) ? <span class="number">0</span></span><br><span class="line">            : workers.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中活跃线程的数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActiveCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池线程的历史最大数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLargestPoolSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> largestPoolSize;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中任务总和(包括已经完成的、正在执行的和未执行的)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">            <span class="keyword">if</span> (w.isLocked())</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + workQueue.size();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池中已经完成的任务总和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCompletedTaskCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> n = completedTaskCount;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            n += w.completedTasks;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="14-总结"><a href="#14-总结" class="headerlink" title="14.总结"></a>14.总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1636037333986-b2a81c36-28ff-4885-a497-a596fe773e6a.png" alt="image.png"></p><h2 id="15-这些问题会答了吗？"><a href="#15-这些问题会答了吗？" class="headerlink" title="15.这些问题会答了吗？"></a>15.这些问题会答了吗？</h2><p>1.Java线程池是如何保证核心线程不被销毁的？<br>2.Java线程池中多余的线程是如何回收的？<br>3.ThreadPoolExecutor中创建的线程如何被复用的？<br>4.线程池如何按照core、max、queue的执行循序去执行？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五、ThreadPoolExecutor&quot;&gt;&lt;a href=&quot;#五、ThreadPoolExecutor&quot; class=&quot;headerlink&quot; title=&quot;五、ThreadPoolExecutor&quot;&gt;&lt;/a&gt;五、ThreadPoolExecutor&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://hevery.top/categories/Java/"/>
    
    
    <category term="JUC" scheme="https://hevery.top/tags/JUC/"/>
    
    <category term="线程池" scheme="https://hevery.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>CompletionService 源码分析</title>
    <link href="https://hevery.top/posts/1007916050/"/>
    <id>https://hevery.top/posts/1007916050/</id>
    <published>2021-11-05T14:05:07.000Z</published>
    <updated>2021-11-08T02:38:01.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个简单的任务编排器："><a href="#一个简单的任务编排器：" class="headerlink" title="一个简单的任务编排器："></a>一个简单的任务编排器：</h1><p>在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且<strong>按任务完成顺序逐个处理</strong>，对于这种场景，Java并发包提供了一个方便的方法，使用<code>CompletionService</code>，这是一个接口，它的实现类是<code>ExecutorCompletionService</code>。<br />​</p><p><code>CompletionService</code>实现了一种行为间的解耦方式，它内部并不关心任务具体如何执行，而是将其交给<code>Executor</code>，而自己只负责对任务执行后的结果进行处理。</p><p>参考文章：<a href="https://www.jianshu.com/p/9a42c5338e95">https://www.jianshu.com/p/9a42c5338e95</a></p><h2 id="类间关系图："><a href="#类间关系图：" class="headerlink" title="类间关系图："></a>类间关系图：</h2><p>组合关系<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678174265-c7af2d9a-e1c6-42ec-b948-9433dd0230ff.png" alt="image.png"></p><p>依赖关系<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678257953-bc03e326-7257-4ea2-bf76-e6e2cbb59a57.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678023402-d5888081-c22c-45ec-9944-e492421f4201.png" alt="image.png"></p><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p><code>CompletionService</code> 的内部维护了一个阻塞队列<code>BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue</code>，当任务执行结束就把任务的执行结果<code>Future</code>加入到阻塞队列中，然后我们就可以从阻塞队列中获取完成的任务。对于<code>FutureTask</code>，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用<code>finishCompletion</code>方法，而该方法会调用一个<code>done</code>方法，<code>ExecutorCompletionService</code>重写了<code>FutureTask</code>的<code>done</code>方法，把<code>Executor</code>执行的计算结果放入<code>BlockingQueue</code>中。</p><h2 id="接口关系图："><a href="#接口关系图：" class="headerlink" title="接口关系图："></a>接口关系图：</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635676666346-e783c4dd-0e44-4768-b742-bcf04687f5fd.png" alt="image.png"><br><a name="P0boz"></a></p><h1 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务的线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line"><span class="comment">// 存放已完成任务的阻塞队列，默认使用 LinkedBlockingQueue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br></pre></td></tr></table></figure><p><a name="fSK2S"></a></p><h1 id="核心内部类"><a href="#核心内部类" class="headerlink" title="核心内部类"></a>核心内部类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将任务FutureTask做了扩展，实现了FutureTask的done方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueingFuture</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="keyword">super</span>(task, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当任务完成后会回调这个方法，这时我们在这个方法中将完成的任务放到队列中，</span></span><br><span class="line">    <span class="comment">// 就实现了按照异步任务完成的顺序，逐个处理任务的结果了。</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="sg1GV"></a></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>在构造函数中我们至少需要传入一个<code>Executor</code>线程池的实现来执行异步任务，但是建议再传入一个阻塞队列，默认的<code>LinkedBlockingQueue</code>是一个无界队列，有内存溢出的风险。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="comment">// 自定义executor没有继承AbstractExecutorService，aes就为null</span></span><br><span class="line">    <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">        (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 构造没有指定的话，默认使用一个无界阻塞队列</span></span><br><span class="line">    <span class="keyword">this</span>.completionQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorCompletionService</span><span class="params">(Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span> || completionQueue == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.aes = (executor <span class="keyword">instanceof</span> AbstractExecutorService) ?</span><br><span class="line">        (AbstractExecutorService) executor : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.completionQueue = completionQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="P7Lgm"></a></p><h1 id="submit提交任务"><a href="#submit提交任务" class="headerlink" title="submit提交任务"></a>submit提交任务</h1><p>提交任务前将task封装为<code>QueueingFuture</code>，当任务执行完成后就会回调<code>done</code>方法，放入任务队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 Callable 任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 封装为 QueueingFuture</span></span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture(f));</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 Runnable 任务，带返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 封装为 QueueingFuture</span></span><br><span class="line">    RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class="line">    executor.execute(<span class="keyword">new</span> QueueingFuture(f));</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aes == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;V&gt;(task);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> aes.newTaskFor(task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RunnableFuture&lt;V&gt; <span class="title">newTaskFor</span><span class="params">(Runnable task, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是自定义Executor的话，默认使用FutureTask</span></span><br><span class="line">    <span class="keyword">if</span> (aes == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;V&gt;(task, result);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> aes.newTaskFor(task, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="HvyHn"></a></p><h1 id="获取已完成的任务"><a href="#获取已完成的任务" class="headerlink" title="获取已完成的任务"></a>获取已完成的任务</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有任务，一直阻塞，直到有新任务进来</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.take();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有任务返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeout时间内获取任务，没有返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> completionQueue.poll(timeout, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个简单的任务编排器：&quot;&gt;&lt;a href=&quot;#一个简单的任务编排器：&quot; class=&quot;headerlink&quot; title=&quot;一个简单的任务编排器：&quot;&gt;&lt;/a&gt;一个简单的任务编排器：&lt;/h1&gt;&lt;p&gt;在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望</summary>
      
    
    
    
    <category term="Java" scheme="https://hevery.top/categories/Java/"/>
    
    
    <category term="JUC" scheme="https://hevery.top/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://hevery.top/posts/1243066710/"/>
    <id>https://hevery.top/posts/1243066710/</id>
    <published>2021-11-04T19:41:34.736Z</published>
    <updated>2021-11-08T02:38:01.706Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
