<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JDK11 线程池源码分析</title>
      <link href="/2021/11/07/JDK11%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/11/07/JDK11%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本源码系列均为JDK11版本，写文章之前曾对比过JDK11与JDK8版本之间的差异，总的来说，核心逻辑变化不大，但JDK11相比之前的JDK8，变量命名更加规范、代码更加简练、优化了很多糟糕的判断逻辑、方法抽象更加模块化。当然读者也可以将JDK11和JDK8配合使用，感受一下代码重构之美<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635998035633-eeb688db-2107-4282-a3ea-3ef4b38b139c.png" alt="image.png">。</p></blockquote><blockquote><p>线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的的内存空间。在线程销毁时需要回收这些系统资源。<br>线程池的作用：</p><ul><li>使用池化技术管理并复用线程、控制最大并发数。</li><li>实现任务线程队列的缓存策略和拒绝机制。</li><li>利用某些与时间相关的功能，比如定时执行、周期执行。</li><li>隔离线程环境，不同的服务配置不同的线程池，避免相互影响。</li></ul></blockquote><blockquote><p>参考文章：<br><a href="https://www.cnblogs.com/wang-meng/p/12945703.html">https://www.cnblogs.com/wang-meng/p/12945703.html</a>  &lt;—- 基于JDK8，是我目前看过最牛逼的线程池源码解析<br><a href="https://juejin.cn/post/6844903494621773832#heading-1">https://juejin.cn/post/6844903494621773832#heading-1</a>&lt;—- 基于JDK8，比较全<br><a href="https://segmentfault.com/a/1190000023546243">https://segmentfault.com/a/1190000023546243</a> &lt;—- 基于JDK11，算是比较新了，但是有几处错误需注意</p></blockquote><h1 id="一、总体设计"><a href="#一、总体设计" class="headerlink" title="一、总体设计"></a>一、总体设计</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662135442-1518e558-6eea-46d0-972e-784f5301d3b9.png" alt="image.png"></p><p>类关系说明图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662467701-8f842874-7606-4e0c-9eae-17c8d5b0a60d.png" alt="image.png">：继承关系<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662651966-21e5dde9-cb27-417d-8f72-51dd88c67a80.png" alt="image.png">：实现关系<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635662525013-8b913fcd-0d60-4e3d-9128-9c8223e1877c.png" alt="image.png">：依赖关系(作为参数或返回值)</p><blockquote><p>线程池的设计本质上和JDK中的集合框架、AQS设计一样，都是使用<strong>模板方法设计模式</strong>。<code>ExecutorService</code>接口继承了<code>Executor</code>接口，定义了管理线程任务的方法，<code>AbstractExecutorService</code>抽象类实现了<code>ExecutorService</code>接口，并提供了<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code>等部分方法的实现。但是核心方法<code>Executor.execute()</code>交由子类<code>ThreadPoolExecutor</code>和<code>ForkJoinPool</code>来分别实现。<code>Executors</code>工具类的静态工厂方法可以创建<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>、<code>ForkJoinPool</code>等线程池的包装对象。</p></blockquote><h1 id="二、Executor"><a href="#二、Executor" class="headerlink" title="二、Executor"></a>二、Executor</h1><blockquote><p><code>Executor</code>接口的设计思想是将任务的创建和任务的执行进行解耦，使用者只需制定任务的执行逻辑(Runnable)，无需关心任务在线程池中是如何被调度的以及线程创建和销毁。</p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669110622-2d22086e-718d-4c12-be90-e332be3f417c.png" width="35%" height="35%"/></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Executor &#123;&#x2F;&#x2F; 提交任务给执行器，由执行器负责去执行任务    void execute(Runnable command);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、ExecutorService"><a href="#三、ExecutorService" class="headerlink" title="三、ExecutorService"></a>三、ExecutorService</h1><blockquote><ul><li><p>扩充Executor能力：可以提交一个或多个任务，获取任务的执行结果</p></li><li><p>提供管理线程任务的方法：终止线程池的运行，回收资源</p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669136644-d0a7ee89-e513-4f31-9196-056e1a82da3b.png" width="75%" height="75%"/></li></ul></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ExecutorService extends Executor &#123;    &#x2F;&#x2F; 关闭线程池，已提交的任务继续执行，不接受继续提交新任务    void shutdown();    &#x2F;&#x2F; 关闭线程池，尝试停止所有正在执行的任务，停止等待任务的处理，并且返回等待执行的任务列表    List&lt;Runnable&gt; shutdownNow();    &#x2F;&#x2F; 判断线程池是否已关闭(不对外接受任务，相当店里于打烊了，里面还在收拾东西)    boolean isShutdown();    &#x2F;&#x2F; 判断线程池是否终止(店里关灯了，收拾完了)    boolean isTerminated();    &#x2F;&#x2F; 等待一段时间，如果到超时了，还没有terminated则返回false，反之则线程池已经terminated，返回true。    boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;    &#x2F;&#x2F; 提交一个有返回值的任务，返回一个表示该任务挂起结果的Future，    &#x2F;&#x2F; 可使用Future的get方法获取任务成功完成时的返回结果    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    &#x2F;&#x2F; 同上，result可以接受返回结果，    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    &#x2F;&#x2F; 提交一个无返回值的任务    Future&lt;?&gt; submit(Runnable task);    &#x2F;&#x2F; 执行所有任务，返回一个 Future 类型的 List    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;    &#x2F;&#x2F; 同上，但设置了超时时间    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;    &#x2F;&#x2F; 只要一个任务结束了，就可以返回该任务的执行结果    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;    &#x2F;&#x2F; 同上，但设置了超时时间    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="四、AbstractExecutorService"><a href="#四、AbstractExecutorService" class="headerlink" title="四、AbstractExecutorService"></a>四、AbstractExecutorService</h1><blockquote><p><code>AbstractExecutorService</code>实现了 <code>submit()</code>、<code>invokeAny()</code> 和 <code>invokeAll()</code> 方法(<strong>利用模板方法设计模式</strong>)，但它们只是在方法内部调用了<code>execute</code>方法，需要等具体执行器来实现这个最重要的部分，私有方法<code>newTaskFor()</code>将<code>Runnable</code>包装为<code>FutureTask</code>。定义于最上层接口 Executor中的<code>void execute(Runnable command)</code>由于不需要获取结果，不会进行 <code>FutureTask</code> 的包装。需要获取结果<code>FutureTask</code>，用 <code>submit()</code> 方法，不需要获取结果，可以用 <code>execute()</code> 方法。</p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635669315780-7e3fa7a4-938d-42f8-bdaa-3e6459423835.png" width="75%" height="75%"/></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractExecutorService implements ExecutorService &#123;    &#x2F;&#x2F; 将Runnable包装为FutureTask，用于submit调用    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;        return new FutureTask&lt;T&gt;(runnable, value);    &#125;    &#x2F;&#x2F; 将Callable包装为FutureTask，用于submit调用    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;        return new FutureTask&lt;T&gt;(callable);    &#125;    &#x2F;&#x2F; 提交任务，使用了模板方法设计模式    public Future&lt;?&gt; submit(Runnable task) &#123;        if (task &#x3D;&#x3D; null) throw new NullPointerException();        &#x2F;&#x2F; 1.将任务包装成FutureTask        RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);        &#x2F;&#x2F; 2.交给执行器执行，具体执行逻辑由子类实现        execute(ftask);        return ftask;    &#125;    &#x2F;&#x2F; 提交任务，带返回结果    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;        if (task &#x3D;&#x3D; null) throw new NullPointerException();        &#x2F;&#x2F; 1.将任务包装成FutureTask        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);        &#x2F;&#x2F; 2.交给执行器执行，具体执行逻辑由子类实现        execute(ftask);        return ftask;    &#125;    &#x2F;&#x2F; 提交任务，带返回结果    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;        if (task &#x3D;&#x3D; null) throw new NullPointerException();        &#x2F;&#x2F; 1.将任务包装成FutureTask        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);        &#x2F;&#x2F; 2.交给执行器执行，具体执行逻辑由子类实现        execute(ftask);        return ftask;    &#125;    &#x2F;&#x2F; Invoke：调用、激活    &#x2F;&#x2F; 将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了    &#x2F;&#x2F; 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，    &#x2F;&#x2F; 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                              boolean timed, long nanos)        throws InterruptedException, ExecutionException, TimeoutException &#123;        if (tasks &#x3D;&#x3D; null)            throw new NullPointerException();        int ntasks &#x3D; tasks.size();        if (ntasks &#x3D;&#x3D; 0)            throw new IllegalArgumentException();        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);        &#x2F;&#x2F; 初始化ExecutorCompletionService，this作为其内部的执行器        &#x2F;&#x2F; ExecutorCompletionService使我们可以按任务的完成顺序从中取出对应的Future        ExecutorCompletionService&lt;T&gt; ecs &#x3D;            new ExecutorCompletionService&lt;T&gt;(this);        &#x2F;&#x2F; For efficiency, especially in executors with limited        &#x2F;&#x2F; parallelism, check to see if previously submitted tasks are        &#x2F;&#x2F; done before submitting more of them. This interleaving        &#x2F;&#x2F; plus the exception mechanics account for messiness of main        &#x2F;&#x2F; loop.&#x2F;&#x2F; 为了更高效的利用执行器(有限的并行度)，在提交更多任务之前检查之前已经提交的        &#x2F;&#x2F; 任务是否已经完成。这个错综复杂的逻辑再加上异常处理机制可能导致了下面for循环的复杂度        try &#123;            &#x2F;&#x2F; Record exceptions so that if we fail to obtain any            &#x2F;&#x2F; result, we can throw the last exception we got.            &#x2F;&#x2F; 记录异常，如果我们得到任何有效结果，我们可以抛出最后一个得到的异常            ExecutionException ee &#x3D; null;            final long deadline &#x3D; timed ? System.nanoTime() + nanos : 0L;            Iterator&lt;? extends Callable&lt;T&gt;&gt; it &#x3D; tasks.iterator();            &#x2F;&#x2F; 先提交一个任务，后续任务到下面的for循环中一个一个提交            futures.add(ecs.submit(it.next()));            &#x2F;&#x2F; 上面提交了一个任务，所以任务数减 1            --ntasks;            &#x2F;&#x2F; 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)            int active &#x3D; 1;            for (;;) &#123;                &#x2F;&#x2F; 以非阻塞的方式获取一个任务的执行结果 Future                Future&lt;T&gt; f &#x3D; ecs.poll();                &#x2F;&#x2F; Future 获取失败                if (f &#x3D;&#x3D; null) &#123;                    &#x2F;&#x2F; 提交下一个任务                    &#x2F;&#x2F; 假设一个任务执行时间很长(一个也没获取到)，那么只好先把所有的任务先提交                    if (ntasks &gt; 0) &#123;                        --ntasks;                        futures.add(ecs.submit(it.next()));                        ++active;                    &#125;                                     &#x2F;&#x2F; 此处应用场景：因为break退出循环之后，必然会抛出异常ee，所以此处的发生应该是在                    &#x2F;&#x2F; 下面执行return f.get()时发生了异常，而此处正是该异常的一个出口，跳出for循环后                    &#x2F;&#x2F; 会调用throw ee 抛出                    else if (active &#x3D;&#x3D; 0)                        break;                    &#x2F;&#x2F; 这里是else if，说明ntask &lt;&#x3D; 0，即已经提交完所有的任务，但是还没有获取到一个任务                    &#x2F;&#x2F; 如果设置了获取任务的超时时间，那么将尝试在nanos时间内获取一个任务的执行结果                    else if (timed) &#123;                        f &#x3D; ecs.poll(nanos, TimeUnit.NANOSECONDS);                        &#x2F;&#x2F; 超时的话抛出异常                        if (f &#x3D;&#x3D; null)                            throw new TimeoutException();                        nanos &#x3D; deadline - System.nanoTime();                    &#125;                    &#x2F;&#x2F; 如果已经提交完所有任务也没有设置超时时间，                    &#x2F;&#x2F; 那么就尝试以阻塞的方式获取一个任务的执行结果                    &#x2F;&#x2F; 这个时候会一直等，直到获取到一个任务的执行结果                    else                        f &#x3D; ecs.take();                &#125;                &#x2F;&#x2F; Future 获取成功                if (f !&#x3D; null) &#123;                    &#x2F;&#x2F; 正在执行的任务数 -1                    --active;                    try &#123;                        &#x2F;&#x2F; 返回执行结果，如果有异常，都包装成ExecutionException                        return f.get();                    &#125; catch (ExecutionException eex) &#123;                        ee &#x3D; eex;                    &#125; catch (RuntimeException rex) &#123;                        ee &#x3D; new ExecutionException(rex);                    &#125;                &#125;            &#125;            if (ee &#x3D;&#x3D; null)                ee &#x3D; new ExecutionException();            throw ee;        &#125; finally &#123;            &#x2F;&#x2F; 方法退出之前，取消其他任务，            &#x2F;&#x2F; 不会取消已完成的任务(对于已完成的任务，取消没有什么效果)            cancelAll(futures);        &#125;    &#125;    &#x2F;&#x2F; 不带超时时间的 invokeAny    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException &#123;        try &#123;            return doInvokeAny(tasks, false, 0);        &#125; catch (TimeoutException cannotHappen) &#123;            assert false;            return null;        &#125;    &#125;    &#x2F;&#x2F; 带超时时间的 invokeAny    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                           long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException &#123;        return doInvokeAny(tasks, true, unit.toNanos(timeout));    &#125;    &#x2F;&#x2F; 执行所有的任务，返回任务结果    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException &#123;        if (tasks &#x3D;&#x3D; null)            throw new NullPointerException();        &#x2F;&#x2F; 包含所有任务执行结果的 Future 列表        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        try &#123;            for (Callable&lt;T&gt; t : tasks) &#123;                &#x2F;&#x2F; 包装成 FutureTask                RunnableFuture&lt;T&gt; f &#x3D; newTaskFor(t);                futures.add(f);                &#x2F;&#x2F; 提交任务                execute(f);            &#125;            for (int i &#x3D; 0, size &#x3D; futures.size(); i &lt; size; i++) &#123;                Future&lt;T&gt; f &#x3D; futures.get(i);                if (!f.isDone()) &#123;                    try &#123;                        &#x2F;&#x2F; 这是一个阻塞方法，直到获取到值，或抛出了异常                        &#x2F;&#x2F; 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的                        &#x2F;&#x2F; 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了                        f.get();                    &#125;                    catch (CancellationException | ExecutionException ignore) &#123;&#125;                &#125;            &#125;            &#x2F;&#x2F; 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来            &#x2F;&#x2F; 这个方法返回是包含所有任务执行结果的 Future 列表            return futures;        &#125; catch (Throwable t) &#123;            &#x2F;&#x2F; 发生异常，取消所有的 Future            cancelAll(futures);            throw t;        &#125;    &#125;    &#x2F;&#x2F; 带超时的 invokeAll    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                         long timeout, TimeUnit unit)        throws InterruptedException &#123;        if (tasks &#x3D;&#x3D; null)            throw new NullPointerException();        long nanos &#x3D; unit.toNanos(timeout);        &#x2F;&#x2F; 截止时间        final long deadline &#x3D; System.nanoTime() + nanos;        ArrayList&lt;Future&lt;T&gt;&gt; futures &#x3D; new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        int j&#x3D;0;        timeOut:try &#123;            for (Callable&lt;T&gt; t : tasks)                futures.add(newTaskFor(t));            final int size &#x3D; futures.size();            &#x2F;&#x2F; Interleave time checks and calls to execute in case            &#x2F;&#x2F; executor doesn&#39;t have any&#x2F;much parallelism.            for (int i &#x3D; 0; i &lt; size; i++) &#123;                if (((i &#x3D;&#x3D; 0) ? nanos : deadline - System.nanoTime()) &lt;&#x3D; 0L)                    &#x2F;&#x2F; 如果提交任务时就超时，直接break                    break timedOut;                &#x2F;&#x2F; 提交任务                execute((Runnable)futures.get(i));            &#125;&#x2F;&#x2F; 获取完成的任务            for (; j &lt; size; j++) &#123;                Future&lt;T&gt; f &#x3D; futures.get(j);                if (!f.isDone()) &#123;                    try &#123; f.get(deadline - System.nanoTime(), NANOSECONDS); &#125;                    catch (CancellationException | ExecutionException ignore) &#123;&#125;                    catch (TimeoutException timedOut) &#123;                        &#x2F;&#x2F; 某个任务获取超时了，就 break                        break timedOut;                    &#125;                &#125;            &#125;            return futures;        &#125;        &#x2F;&#x2F; 走到这里应该是超时 break 了，所以取消还没有完成的 Future        cancelAll(futures, j);        return futures;    &#125;    &#x2F;&#x2F; 取消所有的 Future    private static &lt;T&gt; void cancelAll(ArrayList&lt;Future&lt;T&gt;&gt; futures) &#123;        cancelAll(futures, 0);    &#125;    &#x2F;&#x2F; 取消索引 j 之后所有的 Future    private static &lt;T&gt; void cancelAll(ArrayList&lt;Future&lt;T&gt;&gt; futures, int j) &#123;        for (int size &#x3D; futures.size(); j &lt; size; j++)            futures.get(j).cancel(true);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>:::success<br><strong>番外篇：Runnable在执行时也是通过适配器模式被包装成Callable。</strong><br><strong>看如下解释：</strong><br>:::</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractExecutorService implements ExecutorService &#123;    &#x2F;&#x2F; 上面代码的其中一小段(将Runnable包装为FutureTask，用于submit调用)    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;        return new FutureTask&lt;T&gt;(runnable, value);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;public FutureTask(Runnable runnable, V result) &#123;        &#x2F;&#x2F; 调用Executors工具类的静态工厂callable方法        this.callable &#x3D; Executors.callable(runnable, result);        this.state &#x3D; NEW;       &#x2F;&#x2F; ensure visibility of callable    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Executors &#123;    public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;        if (task &#x3D;&#x3D; null)            throw new NullPointerException();        &#x2F;&#x2F; 将Runnable包装成一个向Callable转化的适配器RunnableAdapter        return new RunnableAdapter&lt;T&gt;(task, result);    &#125;&#x2F;&#x2F; 适配器设计模式    static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;        final Runnable task;        final T result;        RunnableAdapter(Runnable task, T result) &#123;            this.task &#x3D; task;            this.result &#x3D; result;        &#125;        public T call() &#123;            task.run();            return result;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="五、ThreadPoolExecutor"><a href="#五、ThreadPoolExecutor" class="headerlink" title="五、ThreadPoolExecutor"></a>五、ThreadPoolExecutor</h1><blockquote><p><code>ThreadPoolExecutor</code> 是 JDK 中的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等方法。<br>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的<code>ScheduledThreadPoolExecutor</code> 就继承自 <code>ThreadPoolExecutor</code>。<br>线程池是一种生产者-消费者模式，线程池的使用方式生产者，线程池本身是消费者。</p></blockquote><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635750405102-47c1b067-ab23-4887-af79-ff574c6bda91.png" width="75%" height="75%" /><p><strong>写在前面</strong>：很多人认为线程池的源码复杂，其实核心逻辑就是上面这幅图展示的，它的复杂在于需要随时随地对线程池的状态进行判断、对线程池中线程数量进行判断、对任务队列是否为空进行判断等等，因为线程池通常是被多个线程同时调用的，很有可能其中某个线程进行了<code>shutdown()</code>、<code>shutdownNow()</code>等操作，甚至在线程池运行期间通过<code>setCorePoolSize()</code>、<code>setMaximumPoolSize()</code>、<code>setKeepAliveTime()</code>、<code>allowsCoreThreadTimeOut()</code>等方法动态调整参数，而这些都是需要线程池”<strong>时刻提防</strong>“的，所以才有了看起来很复杂的判断逻辑，当我们在遇到它们的时候，如果带着上面的思考再去考虑可能遇到的各种情况，或许就豁然开朗了。还有一点，在代码的关键部分保留了英文注释，可以结合着讲解一些看，它是我们读懂作者设计思路的一手资源。</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) &#123;        if (corePoolSize &lt; 0 ||            maximumPoolSize &lt;&#x3D; 0 ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; 0)            throw new IllegalArgumentException();        if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)            throw new NullPointerException();        this.acc &#x3D; System.getSecurityManager() &#x3D;&#x3D; null ?                null :                AccessController.getContext();    &#x2F;&#x2F; 核心线程数        this.corePoolSize &#x3D; corePoolSize;    &#x2F;&#x2F; 最大线程数，线程池允许创建的最大线程数        this.maximumPoolSize &#x3D; maximumPoolSize;    &#x2F;&#x2F; 任务队列        this.workQueue &#x3D; workQueue;    &#x2F;&#x2F; 非核心线程获取任务时的等待时间，超时后就会被销毁    &#x2F;&#x2F; 当然，也可以通过调用 allowCoreThreadTimeOut(true) 使核心线程数内的线程也可以被回收。        this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);    &#x2F;&#x2F; 线程工厂，它用来生产一组相同任务的线程，线程池的命名是通过给这个 factory 增加组名前缀来实现的。    &#x2F;&#x2F; 在虚拟机栈分析时，就可以知道线程任务是有哪个线程工厂生产的。        this.threadFactory &#x3D; threadFactory;    &#x2F;&#x2F; 拒绝策略        this.handler &#x3D; handler;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面的构造方法是<code>ThreadPoolExecutor</code>中最全的一个构造方法。这里我们重点说一下<code>threadFactory</code>这个参数。<br>如果在构造函数中不传<code>threadFactory</code>，默认使用的是<code>Executors.defaultThreadFactory()</code>，实现如下，我们在实际应用中通常需要根据自己的业务，重新定义线程工厂，为线程指定有意义的名称和序列号。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Executors &#123;    &#x2F;&#x2F; 静态工厂方法，返回线程池默认的线程工厂实现    public static ThreadFactory defaultThreadFactory() &#123;        return new DefaultThreadFactory();    &#125;    static class DefaultThreadFactory implements ThreadFactory &#123;        private static final AtomicInteger poolNumber &#x3D; new AtomicInteger(1);        private final ThreadGroup group;        private final AtomicInteger threadNumber &#x3D; new AtomicInteger(1);        private final String namePrefix;        DefaultThreadFactory() &#123;            SecurityManager s &#x3D; System.getSecurityManager();            group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() :            Thread.currentThread().getThreadGroup();            namePrefix &#x3D; &quot;pool-&quot; +                poolNumber.getAndIncrement() +                &quot;-thread-&quot;;        &#125;        public Thread newThread(Runnable r) &#123;            Thread t &#x3D; new Thread(group, r,                                  namePrefix + threadNumber.getAndIncrement(),                                  0);            if (t.isDaemon())                t.setDaemon(false);            if (t.getPriority() !&#x3D; Thread.NORM_PRIORITY)                t.setPriority(Thread.NORM_PRIORITY);            return t;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>RejectedExecutionHandler</code>表示拒绝策略，它的执行时机是当阻塞队列已满且没有空闲的线程(包括核心和非核心)时对新提交过来的任务的执行策略。<code>ThreadPoolExecutor</code>内部实现了四种拒绝策略，它们是四个公共的静态内部类，都实现了<code>RejectedExecutionHandler</code>这个接口。由于内建的这几种策略都有各自的局限性，所以我们在工作中一般会制定自己的拒绝策略。下面我们看一下内建的四种拒绝策略：</p></blockquote><ul><li>AbortPolicy：默认的拒绝策略，直接抛出异常</li><li>DiscardPolicy：忽略提交的任务(里面是个空实现)</li><li>DiscardOldestPolicy：抛弃最老的任务，通过<code>poll()</code>方法取出任务队列队头的任务抛弃，然后提交当期任务</li><li>CallerRunsPolicy：让调用者线程执行当前被拒绝任务，这样原来的异步调用会退化为同步调用，所以我们一般不推荐这么做。<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface RejectedExecutionHandler &#123;    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreadPoolExecutor extends AbstractExecutorService &#123;        &#x2F;&#x2F; 默认的拒绝策略    private static final RejectedExecutionHandler defaultHandler &#x3D; new AbortPolicy();        public static class AbortPolicy implements RejectedExecutionHandler &#123;                public AbortPolicy() &#123; &#125;        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;            &#x2F;&#x2F; 直接抛出异常            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +                                                 &quot; rejected from &quot; +                                                 e.toString());        &#125;    &#125;         public static class DiscardPolicy implements RejectedExecutionHandler &#123;               public DiscardPolicy() &#123; &#125;        &#x2F;&#x2F; 忽略任务 do nothing        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;        &#125;     &#125;     public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;                public DiscardOldestPolicy() &#123; &#125;        &#x2F;&#x2F; 抛弃队头任务，提交当前任务        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;            if (!e.isShutdown()) &#123;                e.getQueue().poll();                e.execute(r);            &#125;        &#125;    &#125;        public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;               public CallerRunsPolicy() &#123; &#125;        &#x2F;&#x2F; 让当前调用Executor#execute()的线程直接调用任务Runnable#run()        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;            if (!e.isShutdown()) &#123;                r.run();            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-线程池状态"><a href="#2-线程池状态" class="headerlink" title="2.线程池状态"></a>2.线程池状态</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; ctl存储线程池状态和线程数private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));&#x2F;&#x2F; Integer 共有 32 位，低 29 位表示工作线程数，高 3 位表示线程池状态private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;&#x2F;&#x2F; 最大线程数 000-11111 11111111 11111111 11111111&#x2F;&#x2F; 这里得到 29 个 1，用法类似于子网掩码，用于位与运算private static final int COUNT_MASK   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;&#x2F;&#x2F; -1的补码(32个1)： 111-11111 11111111 11111111 11111111&#x2F;&#x2F; 所以左移32位结果： 111-00000 00000000 00000000 00000000&#x2F;&#x2F; 此状态表示线程池能够接受新任务private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F; 000-00000 00000000 00000000 00000000private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;&#x2F;&#x2F; 001-00000 00000000 00000000 00000000private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;&#x2F;&#x2F; 010-00000 00000000 00000000 00000000private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;&#x2F;&#x2F; 011-00000 00000000 00000000 00000000private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;&#x2F;&#x2F; CAPACITY 按位取反，高 3 变为 1，低 29 位变为 0&#x2F;&#x2F; 比如： 001-00000 00000000 00000000 00000011 表示当前有3个线程&#x2F;&#x2F; ~CAPACITY: 111-00000 00000000 00000000 00000000&#x2F;&#x2F; 按位与后:   001-00000 00000000 00000000 00000000 表示线程池处于 stop 状态&#x2F;&#x2F; 获取当前线程池的状态(高3位)private static int runStateOf(int c)     &#123; return c &amp; ~COUNT_MASK; &#125;&#x2F;&#x2F; 获取线程池中的线程数(低29位)private static int workerCountOf(int c)  &#123; return c &amp; COUNT_MASK; &#125;&#x2F;&#x2F; 上面的操作的反向：根据运行状态和线程数获取 ctlprivate static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;&#x2F;&#x2F; 下面三个方法都是通过 ctl 来判断线程池状态private static boolean runStateLessThan(int c, int s) &#123;    return c &lt; s;&#125;private static boolean runStateAtLeast(int c, int s) &#123;    return c &gt;&#x3D; s;&#125;private static boolean isRunning(int c) &#123;    return c &lt; SHUTDOWN;&#125;&#x2F;&#x2F; 通过 CAS 使线程数 +1private boolean compareAndIncrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect + 1);&#125; &#x2F;&#x2F; 通过 CAS 增加线程数 -1private boolean compareAndDecrementWorkerCount(int expect) &#123;    return ctl.compareAndSet(expect, expect - 1);&#125;&#x2F;**  * Decrements the workerCount field of ctl. This is called only on  * abrupt termination of a thread (see processWorkerExit). Other  * decrements are performed within getTask.  *&#x2F;&#x2F;&#x2F; 线程数直接 -1private void decrementWorkerCount() &#123;    ctl.addAndGet(-1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里重点说一下<code>compareAndDecrementWorkerCount()</code>和<code>decrementWorkerCount()</code>的区别：<br><code>decrementWorkerCount</code>在JDK8中中是这样实现的：<br>private void decrementWorkerCount() {<br>    do {} while (! compareAndDecrementWorkerCount(ctl.get()));<br>}<br>前者会通过返回值来判断线程数 -1 操作是否成功(可能会失败)，而后者是循环直到你  -1 成功！<br>线程池五种状态的十进制从小到大排序依次为：<strong>RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</strong>。</p></blockquote><ul><li>RUNNING：表示正常的状态，接受新的任务，处理等待队列中的任务</li><li>SHUTDOWN：不接受新的任务提交，但会继续处理等待队列中的任务</li><li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>TIDYING：所有任务都销毁了，线程数为0，会执行钩子方法 <code>terminated()</code></li><li>TERMINATED：执行钩子方法 <code>terminated()</code>完毕，线程池彻底关闭</li></ul><blockquote><p>线程池状态轮转图如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635989873122-690788e3-0f30-4b45-a06d-9b60765badc1.png" alt="image.png"></p></blockquote><h2 id="3-execute方法"><a href="#3-execute方法" class="headerlink" title="3.execute方法"></a>3.execute方法</h2><blockquote><p><code>execute()</code>方法是<code>ThreadPoolExecutor</code>的<strong>核心逻辑</strong>，主要负责任务的调度。<br>​<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635826704184-37025c80-6c8c-4389-8134-c59a73ca4e23.png" alt="image.png"></p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void execute(Runnable command) &#123;    if (command &#x3D;&#x3D; null)        throw new NullPointerException();    &#x2F;*         * Proceed in 3 steps:         *         * 1. If fewer than corePoolSize threads are running, try to         * start a new thread with the given command as its first         * task.  The call to addWorker atomically checks runState and         * workerCount, and so prevents false alarms that would add         * threads when it shouldn&#39;t, by returning false.         *         * 2. If a task can be successfully queued, then we still need         * to double-check whether we should have added a thread         * (because existing ones died since last checking) or that         * the pool shut down since entry into this method. So we         * recheck state and if necessary roll back the enqueuing if         * stopped, or start a new thread if there are none.         *         * 3. If we cannot queue task, then we try to add a new         * thread.  If it fails, we know we are shut down or saturated         * and so reject the task.         *&#x2F;&#x2F;&#x2F; 获取ctl的值(之前说的那个表示 &quot;线程池状态&quot; 和 &quot;线程数&quot; 的整数)    int c &#x3D; ctl.get();    &#x2F;&#x2F; 如果线程数小于核心线程数，则创建新的核心线程并执行传入的任务    if (workerCountOf(c) &lt; corePoolSize) &#123;        if (addWorker(command, true))            &#x2F;&#x2F; 创建成功则返回            return;        &#x2F;&#x2F; 创建失败，更新 ctl 的临时变量 c        c &#x3D; ctl.get();    &#125;    &#x2F;&#x2F; 走到这里两种情况：    &#x2F;&#x2F; 1.线程数 &gt;&#x3D; 核心线程数    &#x2F;&#x2F; 2.addWorker 返回 false (线程池状态非 RUNNING)    &#x2F;&#x2F; 所以如果线程池此时处于 RUNNING 状态(针对情况 1 )，则将任务加入任务队列    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        &#x2F;&#x2F; double-check，重新获取线程池的状态        int recheck &#x3D; ctl.get();        &#x2F;&#x2F; 如果线程池此时变为非 RUNNING 状态，则从任务队列中删除任务(roll back)        if (! isRunning(recheck) &amp;&amp; remove(command))            &#x2F;&#x2F; 执行拒绝策略处理任务            reject(command);        &#x2F;&#x2F; 走到这里有两种情况：        &#x2F;&#x2F; 1.线程池处于 RUNNING 状态，线程数 &gt;&#x3D; 核心线程数        &#x2F;&#x2F; 2.线程池处于非 RUNNING 状态，但是上面 remove 失败，        &#x2F;&#x2F; 失败的原因可能是任务在 remove 之前已经出队被执行，这种情况我们无需关心        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)            &#x2F;&#x2F; 对于 RUNNING ，如果当前线程数量为 0，则创建一个非核心线程并且传入的任务对象为 null，            &#x2F;&#x2F; 这里传入 null 是是因为任务已经在任务队列中            &#x2F;&#x2F; 所以这块代码的真正意图是：担心任务提交到任务队列中了，但是此时线程数为0(可能设置了allowCoreThreadTimeOut&#x3D;true)            &#x2F;&#x2F; 那必须有一个线程来执行任务，可以理解为一种兜底机制            addWorker(null, false);        &#x2F;&#x2F; 最后的else分支(假设有，哈哈)对应的情况，线程数不为 0，任务也已经成功入队，所以什么也不用做    &#125;    &#x2F;&#x2F; 走到这里两种情况：    &#x2F;&#x2F; 1.线程池处于非 RUNNING 状态，这时调用 addWorker 肯定返回 false    &#x2F;&#x2F; 2.线程池处于 RUNNING 状态，线程数 &gt;&#x3D; 核心线程数，且任务队列已满，这时需要创建非核心线程来执行该任务    else if (!addWorker(command, false))        &#x2F;&#x2F; 新增失败则执行拒绝策略处理任务        &#x2F;&#x2F; 失败原因：1.线程池处于非 RUNNING 状态 2.线程数超过最大线程数 maximumPoolSize        reject(command);&#125;&#x2F;&#x2F; 从任务队列中移除当前任务 taskpublic boolean remove(Runnable task) &#123;    boolean removed &#x3D; workQueue.remove(task);    &#x2F;&#x2F; 因为调用此方法时线程池处于非运行状态，所以会尝试关闭线程线程池    tryTerminate(); &#x2F;&#x2F; In case SHUTDOWN and now empty    return removed;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>这里比较难理解的是<strong>为什么要double-check?</strong><br>特意没有删了上面的英文注释，对照着我们来简单看一下第二点：<br>如果一个任务成功加入任务队列，我们依然需要二次检查是否需要添加一个工作线程（因为所有存活的工作线程有可能在最后一次检查之后已经终结(<code>workerCountOf(recheck) == 0</code>）或者执行当前方法(<code>workQueue.offer(command)</code>)的时候线程池已经shut down了(<code>! isRunning(recheck)</code>)。所以我们需要二次检查线程池的状态，必要时<strong>把任务从任务队列中移除或者在没有可用的工作线程的前提下新建一个工作线程(对应</strong><code>if (! isRunning(recheck) &amp;&amp; remove(command))</code><strong>和</strong><code>else if (workerCountOf(recheck) == 0)</code>**两个分支)**。</p></blockquote><h2 id="4-addWorker"><a href="#4-addWorker" class="headerlink" title="4.addWorker"></a>4.addWorker</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 参数：firstTask 为每个 Worker 新建时处理的第一个任务，无需从任务队列中取，&#x2F;&#x2F;处理完第一个任务后 Worker 后续会通过 getTask() 方法从任务队列取任务执行&#x2F;&#x2F; 参数：core 表示是否创建核心线程private boolean addWorker(Runnable firstTask, boolean core) &#123;    &#x2F;&#x2F; 响应下文的 continue retry，快速退出多层嵌套循环    retry:    for (int c &#x3D; ctl.get();;) &#123;        &#x2F;&#x2F; runStateAtLeast(c, SHUTDOWN)：为了快速短路，线程池为 RUNNING 的话就不需要执行后面的判断        &#x2F;&#x2F; (runStateAtLeast(c, STOP) || firstTask !&#x3D; null || workQueue.isEmpty())        &#x2F;&#x2F; 1.STOP 即以上状态 ----&gt;都快打扫完了就别添乱了        &#x2F;&#x2F; 2.SHUTDOWN 状态且 firstTask 不为空  ----&gt; 打烊了不接新客了        &#x2F;&#x2F; 3.SHUTDOWN 状态且 firstTask 为空且任务队列为空 -----&gt; 打烊了门口也没新客了店里的人也走完了        if (runStateAtLeast(c, SHUTDOWN)            &amp;&amp; (runStateAtLeast(c, STOP)                || firstTask !&#x3D; null                || workQueue.isEmpty()))            return false;&#x2F;&#x2F; 走到这里两种情况：        &#x2F;&#x2F; 1.线程池为 RUNNING 状态        &#x2F;&#x2F; 2.线程池为 SHUTDOWN 状态，提交任务firstTask为空，任务队列不为空，即 addWorker(null, false)        for (;;) &#123;            &#x2F;&#x2F; 1.创建的是核心线程且线程数量 &gt;&#x3D; 设定的核心线程数             &#x2F;&#x2F; 2.创建的事非核心线程且线程数量 &gt;&#x3D; 设定的最大线程数             &#x2F;&#x2F; 以上两种情况均 return false            if (workerCountOf(c)                &gt;&#x3D; ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))                return false;            &#x2F;&#x2F; 走到这里说明可以创建线程了，CAS 操作线程数量 +1，成功 跳出循环执行后面语句             if (compareAndIncrementWorkerCount(c))                break retry;            c &#x3D; ctl.get();             &#x2F;&#x2F; 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了            &#x2F;&#x2F; 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池            &#x2F;&#x2F; 那么需要回到外层的for循环           &#x2F;&#x2F; 所以这里判断只要线程池不是 RUNNING 状态，就回到最外层循环重新执行            if (runStateAtLeast(c, SHUTDOWN))                continue retry;            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop            &#x2F;&#x2F; 走到这说明是 CAS 失败，存在多个线程同时执行 workCount+1，            &#x2F;&#x2F; 所以只需内部自旋，直到每个线程都 workCount+1 成功        &#125;    &#125;    &#x2F;&#x2F; 走到这里，我们认为当前这个时刻，可以开始创建线程来执行任务了    &#x2F;&#x2F; 表示 worker 是否已经启动    boolean workerStarted &#x3D; false;    &#x2F;&#x2F; 表示 worker 是否创建成功    boolean workerAdded &#x3D; false;    Worker w &#x3D; null;    try &#123;        w &#x3D; new Worker(firstTask);        final Thread t &#x3D; w.thread;        &#x2F;&#x2F; 这里判断t !&#x3D; null是因为用户可以自定义ThreadFactory，        &#x2F;&#x2F; 如果这里用户直接返回null或者因为一些谜之操作创建失败了都应该考虑到，所以需要判断一下        if (t !&#x3D; null) &#123;            &#x2F;&#x2F; 这里需要全局加锁，因为可能会并发修改一些线程池的指标值和hashset(worker 集合)            final ReentrantLock mainLock &#x3D; this.mainLock;            mainLock.lock();            try &#123;                &#x2F;&#x2F; Recheck while holding lock.                &#x2F;&#x2F; Back out on ThreadFactory failure or if                &#x2F;&#x2F; shut down before lock acquired.                &#x2F;&#x2F; 持有锁之后重新获取线程池状态，因为可能在获取锁的过程状态被其他线程更改                int c &#x3D; ctl.get();                &#x2F;&#x2F; 根据逻辑或的短路原则，这里有两种情况：                &#x2F;&#x2F; 1.线程池状态为RUNNING                &#x2F;&#x2F; 2.线程池状态为SHUTDOWN，并且传入的任务实例 firstTask 为 null，                &#x2F;&#x2F;   因为在SHUTDOWN状态时不会再添加新的任务，但是可以继续处理workQueue中的任务                if (isRunning(c) ||                    (runStateLessThan(c, STOP) &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;                    &#x2F;&#x2F; 此时线程的状态为新建但没有启动，否则抛出异常                    if (t.getState() !&#x3D; Thread.State.NEW)                        throw new IllegalThreadStateException();                    &#x2F;&#x2F; 把新建的 worker 加入到 workers 集合中                     workers.add(w);                    workerAdded &#x3D; true;                    int s &#x3D; workers.size();                    &#x2F;&#x2F; 更改线程池的峰值容量(历史的最大容量)                    if (s &gt; largestPoolSize)                        largestPoolSize &#x3D; s;                &#125;            &#125; finally &#123;                mainLock.unlock();            &#125;            if (workerAdded) &#123;                &#x2F;&#x2F; 启动线程                t.start();                workerStarted &#x3D; true;            &#125;        &#125;    &#125; finally &#123;        &#x2F;&#x2F; 线程启动失败，需要从 workers 集合移除对应的 worker        if (! workerStarted)            addWorkerFailed(w);    &#125;    return workerStarted;&#125;&#x2F;&#x2F; 回滚创建的workerprivate void addWorkerFailed(Worker w) &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        if (w !&#x3D; null)            &#x2F;&#x2F; 从 workers 集合中移除启动失败的 worker            workers.remove(w);        &#x2F;&#x2F; 工作线程数量 -1        decrementWorkerCount();        &#x2F;&#x2F; 基于状态判断尝试终结线程池        tryTerminate();    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-Worker"><a href="#6-Worker" class="headerlink" title="6.Worker"></a>6.Worker</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">private final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123;    &#x2F;**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     *&#x2F;    private static final long serialVersionUID &#x3D; 6138294804551838833L;    &#x2F;&#x2F; 保存 ThreadFactory 创建的线程实例，如果 ThreadFactory 创建失败则为 null    final Thread thread;    &#x2F;&#x2F; 保存 Runnable 任务实例    Runnable firstTask;    &#x2F;&#x2F; 记录每个线程完成的任务总数    volatile long completedTasks;    &#x2F;&#x2F; 构造函数，传入任务实例 firstTask，可以为 null    Worker(Runnable firstTask) &#123;        &#x2F;&#x2F; 禁止线程中断，直到 runWorker() 方法运行，看后面 interruptIfStarted() 方法的实现        setState(-1);        this.firstTask &#x3D; firstTask;        &#x2F;&#x2F; 通过 ThreadFactory 创建线程实例，注意一下 Worker 实例自身作为 Runnable 用于创建新的线程         this.thread &#x3D; getThreadFactory().newThread(this);    &#125;    &#x2F;&#x2F; 委托到外部的 runWorker() 方法，注意 runWorker() 是线程池的方法，不是 Worker 的方法    public void run() &#123;        runWorker(this);    &#125;        &#x2F;&#x2F; The value 0 represents the unlocked state.    &#x2F;&#x2F; The value 1 represents the locked state.&#x2F;&#x2F; 是否持有独占锁，state 值为 1 的时候表示持有锁，state 值为 0 的时候表示释放锁    protected boolean isHeldExclusively() &#123;        return getState() !&#x3D; 0;    &#125;    &#x2F;&#x2F; 独占模式下尝试获取资源，这里没有判断传入的变量，直接 CAS 判断 0 更新为 1 是否成功，    &#x2F;&#x2F; 成功则设置独占线程为当前线程    protected boolean tryAcquire(int unused) &#123;        if (compareAndSetState(0, 1)) &#123;            setExclusiveOwnerThread(Thread.currentThread());            return true;        &#125;        return false;    &#125;    &#x2F;&#x2F; 独占模式下尝试释放资源，这里没有判断传入的变量，直接把 state 设置为 0    protected boolean tryRelease(int unused) &#123;        setExclusiveOwnerThread(null);        setState(0);        return true;    &#125;    &#x2F;&#x2F; 加锁    public void lock()        &#123; acquire(1); &#125;    &#x2F;&#x2F; 尝试加锁    public boolean tryLock()  &#123; return tryAcquire(1); &#125;    &#x2F;&#x2F; 解锁    public void unlock()      &#123; release(1); &#125;    &#x2F;&#x2F; 当前 worker 是否被锁定    public boolean isLocked() &#123; return isHeldExclusively(); &#125;    &#x2F;&#x2F; 线程启动后进行中断    &#x2F;&#x2F; 中断条件：线程已经启动，并且中断标志位为 false    void interruptIfStarted() &#123;        Thread t;        if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;            try &#123;                t.interrupt();            &#125; catch (SecurityException ignore) &#123;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>:::info<br><code>Worker</code> 继承自 AQS，这里使用了 AQS 的独占模式，构造<code>Worker</code>的时候，把AQS的资源（状态）通过<code>setState(-1)</code>设置为 -1，这是因为<code>Worker</code>实例刚创建时AQS中<code>state</code>的默认值为0，此时线程尚未启动，不能在这个时候进行线程中断，见Worker#interruptIfStarted()方法。<br>:::</p><h2 id="7-runWorker"><a href="#7-runWorker" class="headerlink" title="7.runWorker"></a>7.runWorker</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">final void runWorker(Worker w) &#123;    &#x2F;&#x2F; 获取当前线程，实际上和 Worker 持有的线程实例是相同的    Thread wt &#x3D; Thread.currentThread();    &#x2F;&#x2F; 获取 Worker 持有的任务对象，存放在临时变量 task 中    Runnable task &#x3D; w.firstTask;    w.firstTask &#x3D; null;    &#x2F;&#x2F; 由于 Worker 初始化时 AQS 中 state 值为 -1，这里要先做一次解锁把 state 置为0，允许线程中断    w.unlock(); &#x2F;&#x2F; allow interrupts    &#x2F;&#x2F; 记录线程是否因用户异常终结，默认 true    boolean completedAbruptly &#x3D; true;    try &#123;        &#x2F;&#x2F; 任务对象不为 null，或者从任务队列获取任务不为空，        while (task !&#x3D; null || (task &#x3D; getTask()) !&#x3D; null) &#123;            w.lock();            &#x2F;&#x2F; If pool is stopping, ensure thread is interrupted;            &#x2F;&#x2F; if not, ensure thread is not interrupted.  This            &#x2F;&#x2F; requires a recheck in second case to deal with            &#x2F;&#x2F; shutdownNow race while clearing interrupt            &#x2F;&#x2F; 如果线程池正在停止，那么要确保当期那工作线程是中断状态，否则，要确保当前线程不是中断状态            &#x2F;&#x2F; 两种情况：            &#x2F;&#x2F; 1.当前线程池状态 &gt;&#x3D; STOP            &#x2F;&#x2F; 2.当前线程目前是已中断的状态 并且线程池的状态也是 &gt;&#x3D; Stop 的            &#x2F;&#x2F; 注意 Thread.interrupted是会擦除中断标识符的，所以 !wt.isInterrupted() 一定返回 true            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try &#123;                &#x2F;&#x2F; 钩子方法，任务执行前                beforeExecute(wt, task);                try &#123;                    task.run();                    &#x2F;&#x2F; 钩子方法，任务执行后 - 正常情况                    afterExecute(task, null);                &#125; catch (Throwable ex) &#123;                    &#x2F;&#x2F; 钩子方法，任务执行后 - 异常情况                    afterExecute(task, ex);                    throw ex;                &#125;            &#125; finally &#123;                &#x2F;&#x2F; 清空 task，准备 getTask 获取下一个任务                &#x2F;&#x2F; 这个很重要，否则 while 会死循环执行同一个 task                task &#x3D; null;                &#x2F;&#x2F; 累计该 Worker 完成的任务数                w.completedTasks++;                &#x2F;&#x2F; Worker 解锁，本质是 AQS 释放资源，设置 state 为 0                 w.unlock();            &#125;        &#125;        &#x2F;&#x2F;         completedAbruptly &#x3D; false;    &#125; finally &#123;        &#x2F;&#x2F; 走到这里，说明 Worker 的一生要结束了：        &#x2F;&#x2F; 1.正常结束，completedAbruptly 为false，getTask 返回为 null，没任务可执行了        &#x2F;&#x2F; 2.异常结束，completedAbruptly 为true，throw ex 中抛出了异常        &#x2F;&#x2F; completedAbruptly为true说明task.run()出现了异常        processWorkerExit(w, completedAbruptly);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>Thread.interrupted()</code>方法用于获取调用方线程的中断状态同时会清空该中断状态，这里之所以会调用这个方法是因为在执行上面这个if逻辑同时外部有可能调用<code>shutdownNow()</code>方法，<code>shutdownNow()</code>方法中也存在中断所有<code>Worker</code>线程的逻辑，但是由于<code>shutdownNow()</code>方法中会遍历所有<code>Worker</code>做线程中断，有可能无法及时在任务提交到<code>Worker</code>执行之前进行中断，所以这个中断逻辑会在<code>Worker</code>内部执行，就是if代码块的逻辑。这里还要注意的是：<code>STOP</code>状态下会拒绝所有新提交的任务，不会再执行任务队列中的任务，同时会中断所有<code>Worker</code>线程。也就是，即使任务<code>Runnable</code>已经在<code>runWorker()中</code>前半段逻辑取出，只要还没走到调用其<code>Runnable#run()</code>，都有可能被中断。假设刚好发生了进入if代码块的逻辑同时外部调用了<code>shutdownNow()</code>方法，那么if逻辑内会判断线程中断状态并且重置，那么<code>shutdownNow()</code>方法中调用的<code>interruptWorkers()</code>就不会因为中断状态判断出现问题导致二次中断线程（会导致异常）。</p></blockquote><h2 id="8-getTask"><a href="#8-getTask" class="headerlink" title="8.getTask"></a>8.getTask</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">private Runnable getTask() &#123;    &#x2F;&#x2F; 上次从任务队列中 poll 是否超时    boolean timedOut &#x3D; false; &#x2F;&#x2F; Did the last poll() time out?    for (;;) &#123;        int c &#x3D; ctl.get();        &#x2F;&#x2F; 1.线程池状态 &gt;&#x3D; STOP ，runStateAtLeast(c, SHUTDOWN) &amp;&amp; runStateAtLeast(c, STOP)        &#x2F;&#x2F; 2.线程池状态 &#x3D;&#x3D; SHUTDOWN &amp;&amp; workQueue.isEmpty()，runStateAtLeast(c, SHUTDOWN) &amp;&amp; !runStateAtLeast(c, STOP) &amp;&amp; workQueue.isEmpty()        &#x2F;&#x2F; 上面的分析其实是剖开了揉碎了来分析很不利于理解，所以大可不必那样        &#x2F;&#x2F; 在我看来这还是一种快速失败机制，因为线程池在正常情况下都是 RUNNING 状态，所以这里第一条件都不符合        &#x2F;&#x2F; 只有当线程池是 SHUTDOWN 的时候，才进一步判断是要变为 STOP(不处理任务队列中的任务)         &#x2F;&#x2F; 还是 任务队列为空(没任务可处理)，故返回 null        if (runStateAtLeast(c, SHUTDOWN)            &amp;&amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) &#123;            &#x2F;&#x2F; 无论如何都要让线程数 -1            decrementWorkerCount();            return null;        &#125;        int wc &#x3D; workerCountOf(c);        &#x2F;&#x2F; Are workers subject to culling?        &#x2F;&#x2F; 判断 worker 是否需要被剔除        &#x2F;&#x2F; 外部如果调用了 allowCoreThreadTimeOut(true)：允许核心线程也使用 keepAliveTime        &#x2F;&#x2F; 那么如果允许核心线程数内的线程回收，或工作线程数超过了核心线程数，都有可能发生超时关闭        boolean timed &#x3D; allowCoreThreadTimeOut || wc &gt; corePoolSize;        &#x2F;&#x2F; 第一个条件：工作线程数大于最大线程数或者线程已经超时        &#x2F;&#x2F; 第二个条件：存活线程数不止一个或者任务队列空了        &#x2F;&#x2F; 同时满足上面两个条件：线程数 -1，不返回任务        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;            if (compareAndDecrementWorkerCount(c))                return null;            continue;        &#125;        &#x2F;&#x2F; 走到这里说明 wc &lt;&#x3D; maximumPoolSize 并且没有超时        try &#123;            &#x2F;&#x2F; timed 为 true：限时等待提取任务队列中的任务(非核心线程或设置了允许超时的核心线程)，超时返回 null            &#x2F;&#x2F; timed 为 false：阻塞等待提取任务队列中的任务(核心线程才会阻塞)            Runnable r &#x3D; timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();            if (r !&#x3D; null)                return r;            &#x2F;&#x2F; r &#x3D;&#x3D; null 说明已超时            timedOut &#x3D; true;        &#125; catch (InterruptedException retry) &#123;            timedOut &#x3D; false;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>getTask()</code>主用于从阻塞队列中获取任务，如果当前线程小于核心线程，那么当阻塞队列中没有任务时就会阻塞，反之会等待<code>keepAliveTime</code>后返回。<br>此处再理解<code>keepAliveTime</code>的使用含义：非核心线程等待新任务的时间，超时的话<code>getTask()</code>方法就会返回<code>null</code>，<code>runWorker()</code>就会执行<code>processWorkerExit()</code>尝试去清理空闲的线程(此时worker的state 等于 0)。</p></blockquote><h2 id="9-processWorkerExit"><a href="#9-processWorkerExit" class="headerlink" title="9.processWorkerExit"></a>9.processWorkerExit</h2><blockquote><p>走到<code>processWorkerExit()</code>这个方法时，有两种情况：一种是<code>runWorker()</code>中调用<code>getTask()</code>返回<code>null</code>(线程池要<code>SHUTDOWN</code>或者非核心线程超时了)，另一种是<code>runWorker()</code>中执行任务发生异常了。这时需要终止这个<code>Worker</code>，所以才会调用这个方法。<br><strong>启示：</strong><code>task#run()</code>里最好是把所有的异常捕获 而不要抛出 不然抛出异常 就会立刻销毁线程 然后创建一个新线程 线程池的作用就没有。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; completedAbruptly 为 true：说明线程执行时出现异常&#x2F;&#x2F; completedAbruptly 为 false：说明 runWorker 由于 getTask 返回 null 正常结束的，&#x2F;&#x2F; getTask方法中已经对 workerCount 进行减一private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;    &#x2F;&#x2F; 非正常结束没来记得及将 workerCount -1，所以此时需要 -1    if (completedAbruptly) &#x2F;&#x2F; If abrupt, then workerCount wasn&#39;t adjusted        decrementWorkerCount();    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        &#x2F;&#x2F; 更新线程池已完成任务数        completedTaskCount +&#x3D; w.completedTasks;        &#x2F;&#x2F; 从 workers 集合中移除该 worker        workers.remove(w);    &#125; finally &#123;        mainLock.unlock();    &#125;&#x2F;&#x2F; 尝试关闭线程池    tryTerminate();    int c &#x3D; ctl.get();    &#x2F;&#x2F; 线程池为 RUNNING 或 SHUTDOWN，如果不是这两个状态，说明线程已经停止了，啥都不会要干了    if (runStateLessThan(c, STOP)) &#123;        &#x2F;&#x2F; 如果是正常结束        if (!completedAbruptly) &#123;            int min &#x3D; allowCoreThreadTimeOut ? 0 : corePoolSize;            &#x2F;&#x2F; 如果允许核心线程超时并且当前队列里面还有任务没跑呢，那就必须留一个线程，不能全死掉.            if (min &#x3D;&#x3D; 0 &amp;&amp; ! workQueue.isEmpty())                min &#x3D; 1;            &#x2F;&#x2F; 如果线程池中线程的数量至少有 1 个，那没事了，至少能执行完任务队列中的任务            if (workerCountOf(c) &gt;&#x3D; min)                return; &#x2F;&#x2F; replacement not needed        &#125;        &#x2F;&#x2F; 走到这里有三种情况        &#x2F;&#x2F; 1.worker 是因为某个异常 task 结束的，并不是我真正想结束，所以需要新增一个 worker        &#x2F;&#x2F; 2.任务队列里还有任务，但是核心线程都关了，这种情况下最起码要留一个线程(可能正在 SHUTDOWN)        &#x2F;&#x2F; 3.当前线程数量 &lt; corePoolSize值，此时会创建线程，维护线程池数量在corePoolSize个水平        addWorker(null, false);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-tryTerminate"><a href="#10-tryTerminate" class="headerlink" title="10.tryTerminate"></a>10.tryTerminate</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">final void tryTerminate() &#123;    for (;;) &#123;        int c &#x3D; ctl.get();        &#x2F;&#x2F; 1.线程池状态为 RUNNING        &#x2F;&#x2F; 2.线程池状态为 TIDYING，不需要你来关了        &#x2F;&#x2F; 3.线程池状态为 SHUTDOWN，但是任务队列还有任务，得等队列中的任务处理完毕后再关        &#x2F;&#x2F; 上面三种情况直接返回        if (isRunning(c) ||            runStateAtLeast(c, TIDYING) ||            (runStateLessThan(c, STOP) &amp;&amp; ! workQueue.isEmpty()))            return;        &#x2F;&#x2F; 走到这里两种情况        &#x2F;&#x2F; 1.线程池状态为 STOP        &#x2F;&#x2F; 2.线程池状态为 SHUTDOWN，但是任务队列为空        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate            &#x2F;&#x2F; 中断一个空闲的 worker            interruptIdleWorkers(ONLY_ONE);            return;        &#125;&#x2F;&#x2F; 走到这里，说明workerCountOf(c) &#x3D;&#x3D; 0，        &#x2F;&#x2F; 在调用 tryTerminate 之前，workerCount已经减为 0，表示这是最后一个退出的线程        final ReentrantLock mainLock &#x3D; this.mainLock;        mainLock.lock();        try &#123;            &#x2F;&#x2F; 设置线程池状态为 TIDYING，如果设置成功，则调用 terminated() 方法            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;                try &#123;                    terminated();                &#125; finally &#123;                    &#x2F;&#x2F; terminated() 执行完毕之后设置状态为 TERMINATED                    ctl.set(ctlOf(TERMINATED, 0));                    &#x2F;&#x2F; 唤醒那些阻塞在 termination 上的线程                    termination.signalAll();                &#125;                return;            &#125;        &#125; finally &#123;            mainLock.unlock();        &#125;        &#x2F;&#x2F; else retry on failed CAS    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="11-interruptIdleWorker"><a href="#11-interruptIdleWorker" class="headerlink" title="11.interruptIdleWorker"></a>11.interruptIdleWorker</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 中断空闲的 workerprivate void interruptIdleWorkers(boolean onlyOne) &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        &#x2F;&#x2F; 遍历 workers，根据 onlyOne 判断是中断一个 worker 还是所有        for (Worker w : workers) &#123;            Thread t &#x3D; w.thread;            &#x2F;&#x2F; 线程没有被中断并且线程是空闲状态 tryLock() 判断是否空闲            &#x2F;&#x2F; 因为worker执行任务上会调用 w.lock()，这时再调用 tryLock() 返回false            if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;                try &#123;                    t.interrupt();                &#125; catch (SecurityException ignore) &#123;                &#125; finally &#123;                    w.unlock();                &#125;            &#125;            if (onlyOne)                break;        &#125;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>遍历<code>workers</code>，如果线程是空闲状态(空闲状态：<code>queue.take()</code>和<code>queue.poll()</code>返回空)，则给其一个中断信号，如果是处于<code>workQueue</code>阻塞的线程，会被唤醒，唤醒后，进入下一次自旋时，可能会<code>return null</code>执行退出相关的逻辑，接着又会调用<code>processWorkerExit()-&gt;tryTerminate()</code>，回到上面场景，当前线程退出的时候还是会继续唤醒下一个空现线程。</p></blockquote><h2 id="12-一些和关闭相关的方法"><a href="#12-一些和关闭相关的方法" class="headerlink" title="12.一些和关闭相关的方法"></a>12.一些和关闭相关的方法</h2><h3 id="1-awaitTermination"><a href="#1-awaitTermination" class="headerlink" title="1.awaitTermination"></a>1.awaitTermination</h3><blockquote><p>还记得上面的<code>tryTerminate()</code>方法中的<code>termination.signalAll()</code>，没错唤醒的就是调用<code>awaitTermination()</code>这个方法的线程。因为<code>awaitTermination()</code>这个方法支持超时，所以如果调用了该方法，并且在超时间内线程池状态还不是 <code>TERMINATED </code>，那么调用该方法的线程就会在条件变<code>private final _Condition _termination = mainLock.newCondition();</code>上等待，直到被中断或者超时。如果等待期间线程池状态变为<code>TERMINATED</code>，那么调用该方法的线程就可能会被唤醒，从而返回 <code>true</code>。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean awaitTermination(long timeout, TimeUnit unit)    throws InterruptedException &#123;    long nanos &#x3D; unit.toNanos(timeout);    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        while (runStateLessThan(ctl.get(), TERMINATED)) &#123;            if (nanos &lt;&#x3D; 0L)                return false;            nanos &#x3D; termination.awaitNanos(nanos);        &#125;        return true;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-shutdown"><a href="#2-shutdown" class="headerlink" title="2.shutdown"></a>2.shutdown</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void shutdown() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        &#x2F;&#x2F; 安全检查：判断调用该方法的线程是否具有关闭线程池的权限        checkShutdownAccess();        &#x2F;&#x2F; RUNNING -&gt; SHUTDOWN 状态转换        advanceRunState(SHUTDOWN);        &#x2F;&#x2F; 中断所有空闲线程，默认 onlyOne 为false        interruptIdleWorkers();        &#x2F;&#x2F; ScheduledThreadPoolExecutor 预留的钩子         onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor    &#125; finally &#123;        mainLock.unlock();    &#125;    tryTerminate();&#125;private void interruptIdleWorkers() &#123;    interruptIdleWorkers(false);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-shutdownNow"><a href="#3-shutdownNow" class="headerlink" title="3.shutdownNow"></a>3.shutdownNow</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public List&lt;Runnable&gt; shutdownNow() &#123;    List&lt;Runnable&gt; tasks;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        checkShutdownAccess();        advanceRunState(STOP);        &#x2F;&#x2F; 中断所有线程，注意和 interruptIdleWorkers 的区别         interruptWorkers();        tasks &#x3D; drainQueue();    &#125; finally &#123;        mainLock.unlock();    &#125;    tryTerminate();    return tasks;&#125;private void interruptWorkers() &#123;    &#x2F;&#x2F; assert mainLock.isHeldByCurrentThread();    for (Worker w : workers)        w.interruptIfStarted();&#125;void interruptIfStarted() &#123;    Thread t;    &#x2F;&#x2F; 不管有没有获得锁 w.lock()，只要线程启动后(可能在执行任务也可能空闲)都可以被中断    if (getState() &gt;&#x3D; 0 &amp;&amp; (t &#x3D; thread) !&#x3D; null &amp;&amp; !t.isInterrupted()) &#123;        try &#123;            t.interrupt();        &#125; catch (SecurityException ignore) &#123;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-isShutdown"><a href="#4-isShutdown" class="headerlink" title="4.isShutdown"></a>4.isShutdown</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isShutdown() &#123;    &#x2F;&#x2F; 线程池状态 &gt;&#x3D; SHUTDOWN，注意并不只是等于    return runStateAtLeast(ctl.get(), SHUTDOWN);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-isTerminating"><a href="#5-isTerminating" class="headerlink" title="5.isTerminating"></a>5.isTerminating</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isTerminating() &#123;    &#x2F;&#x2F; SHUTDOWN &#x3D;&lt; 线程池状态 &lt;&#x3D; TERMINATED    int c &#x3D; ctl.get();    return runStateAtLeast(c, SHUTDOWN) &amp;&amp; runStateLessThan(c, TERMINATED);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-isTerminated"><a href="#6-isTerminated" class="headerlink" title="6.isTerminated"></a>6.isTerminated</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean isTerminated() &#123;    &#x2F;&#x2F; 线程池状态 &gt;&#x3D; TERMINATED    return runStateAtLeast(ctl.get(), TERMINATED);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13线程池的预热和动态调参"><a href="#13线程池的预热和动态调参" class="headerlink" title="13线程池的预热和动态调参"></a>13线程池的预热和动态调参</h2><h3 id="1-核心线程的预热功能"><a href="#1-核心线程的预热功能" class="headerlink" title="1.核心线程的预热功能"></a>1.核心线程的预热功能</h3><p>:::info<br>核心线程启动后可能任务队列为空，此时会阻塞在任务队列上直到有任务进来。<br>:::</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 启动一个核心线程public boolean prestartCoreThread() &#123;    return workerCountOf(ctl.get()) &lt; corePoolSize &amp;&amp;        addWorker(null, true);&#125;&#x2F;&#x2F; 启动所有核心线程public int prestartAllCoreThreads() &#123;    int n &#x3D; 0;    while (addWorker(null, true))        ++n;    return n;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-动态调整线程池参数"><a href="#2-动态调整线程池参数" class="headerlink" title="2.动态调整线程池参数"></a>2.动态调整线程池参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void setCorePoolSize(int corePoolSize) &#123;    if (corePoolSize &lt; 0 || maximumPoolSize &lt; corePoolSize)        throw new IllegalArgumentException();    int delta &#x3D; corePoolSize - this.corePoolSize;    this.corePoolSize &#x3D; corePoolSize;    if (workerCountOf(ctl.get()) &gt; corePoolSize)        interruptIdleWorkers();    else if (delta &gt; 0) &#123;        &#x2F;&#x2F; We don&#39;t really know how many new threads are &quot;needed&quot;.        &#x2F;&#x2F; As a heuristic, prestart enough new workers (up to new        &#x2F;&#x2F; core size) to handle the current number of tasks in        &#x2F;&#x2F; queue, but stop if queue becomes empty while doing so.        int k &#x3D; Math.min(delta, workQueue.size());        while (k-- &gt; 0 &amp;&amp; addWorker(null, true)) &#123;            if (workQueue.isEmpty())                break;        &#125;    &#125;&#125;public void allowCoreThreadTimeOut(boolean value) &#123;    if (value &amp;&amp; keepAliveTime &lt;&#x3D; 0)        throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);    if (value !&#x3D; allowCoreThreadTimeOut) &#123;        allowCoreThreadTimeOut &#x3D; value;        if (value)            interruptIdleWorkers();    &#125;&#125;public void setMaximumPoolSize(int maximumPoolSize) &#123;    if (maximumPoolSize &lt;&#x3D; 0 || maximumPoolSize &lt; corePoolSize)        throw new IllegalArgumentException();    this.maximumPoolSize &#x3D; maximumPoolSize;    if (workerCountOf(ctl.get()) &gt; maximumPoolSize)        interruptIdleWorkers();&#125;public void setKeepAliveTime(long time, TimeUnit unit) &#123;    if (time &lt; 0)        throw new IllegalArgumentException();    if (time &#x3D;&#x3D; 0 &amp;&amp; allowsCoreThreadTimeOut())        throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);    long keepAliveTime &#x3D; unit.toNanos(time);    long delta &#x3D; keepAliveTime - this.keepAliveTime;    this.keepAliveTime &#x3D; keepAliveTime;    if (delta &lt; 0)        interruptIdleWorkers();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-线程池的一些其他参数"><a href="#3-线程池的一些其他参数" class="headerlink" title="3.线程池的一些其他参数"></a>3.线程池的一些其他参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 线程池中线程的数量(包含活跃线程和空闲线程)public int getPoolSize() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        &#x2F;&#x2F; Remove rare and surprising possibility of        &#x2F;&#x2F; isTerminated() &amp;&amp; getPoolSize() &gt; 0        return runStateAtLeast(ctl.get(), TIDYING) ? 0            : workers.size();    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;&#x2F;&#x2F; 线程池中活跃线程的数量public int getActiveCount() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        int n &#x3D; 0;        for (Worker w : workers)            if (w.isLocked())                ++n;        return n;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;&#x2F;&#x2F; 线程池线程的历史最大数量public int getLargestPoolSize() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        return largestPoolSize;    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;&#x2F;&#x2F; 线程池中任务总和(包括已经完成的、正在执行的和未执行的)public long getTaskCount() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        long n &#x3D; completedTaskCount;        for (Worker w : workers) &#123;            n +&#x3D; w.completedTasks;            if (w.isLocked())                ++n;        &#125;        return n + workQueue.size();    &#125; finally &#123;        mainLock.unlock();    &#125;&#125;&#x2F;&#x2F; 线程池中已经完成的任务总和public long getCompletedTaskCount() &#123;    final ReentrantLock mainLock &#x3D; this.mainLock;    mainLock.lock();    try &#123;        long n &#x3D; completedTaskCount;        for (Worker w : workers)            n +&#x3D; w.completedTasks;        return n;    &#125; finally &#123;        mainLock.unlock();    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-总结"><a href="#14-总结" class="headerlink" title="14.总结"></a>14.总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1636037333986-b2a81c36-28ff-4885-a497-a596fe773e6a.png" alt="image.png"></p><h2 id="15-这些问题会答了吗？"><a href="#15-这些问题会答了吗？" class="headerlink" title="15.这些问题会答了吗？"></a>15.这些问题会答了吗？</h2><p>1.Java线程池是如何保证核心线程不被销毁的？<br>2.Java线程池中多余的线程是如何回收的？<br>3.ThreadPoolExecutor中创建的线程如何被复用的？<br>4.线程池如何按照core、max、queue的执行循序去执行？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletionService 源码分析</title>
      <link href="/2021/11/05/CompletionService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2021/11/05/CompletionService%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单的任务编排器："><a href="#一个简单的任务编排器：" class="headerlink" title="一个简单的任务编排器："></a>一个简单的任务编排器：</h1><p>在异步任务程序中，一种常见的场景是，主线程提交多个异步任务，然后希望有任务完成就处理结果，并且<strong>按任务完成顺序逐个处理</strong>，对于这种场景，Java并发包提供了一个方便的方法，使用<code>CompletionService</code>，这是一个接口，它的实现类是<code>ExecutorCompletionService</code>。<br />​</p><p><code>CompletionService</code>实现了一种行为间的解耦方式，它内部并不关心任务具体如何执行，而是将其交给<code>Executor</code>，而自己只负责对任务执行后的结果进行处理。</p><p>参考文章：<a href="https://www.jianshu.com/p/9a42c5338e95">https://www.jianshu.com/p/9a42c5338e95</a></p><h2 id="类间关系图："><a href="#类间关系图：" class="headerlink" title="类间关系图："></a>类间关系图：</h2><p>组合关系<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678174265-c7af2d9a-e1c6-42ec-b948-9433dd0230ff.png" alt="image.png"></p><p>依赖关系<img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678257953-bc03e326-7257-4ea2-bf76-e6e2cbb59a57.png" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635678023402-d5888081-c22c-45ec-9944-e492421f4201.png" alt="image.png"></p><h2 id="基本原理："><a href="#基本原理：" class="headerlink" title="基本原理："></a>基本原理：</h2><p><code>CompletionService</code> 的内部维护了一个阻塞队列<code>BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue</code>，当任务执行结束就把任务的执行结果<code>Future</code>加入到阻塞队列中，然后我们就可以从阻塞队列中获取完成的任务。对于<code>FutureTask</code>，任务完成后，不管是正常完成、异常结束、还是被取消，都会调用<code>finishCompletion</code>方法，而该方法会调用一个<code>done</code>方法，<code>ExecutorCompletionService</code>重写了<code>FutureTask</code>的<code>done</code>方法，把<code>Executor</code>执行的计算结果放入<code>BlockingQueue</code>中。</p><h2 id="接口关系图："><a href="#接口关系图：" class="headerlink" title="接口关系图："></a>接口关系图：</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12988769/1635676666346-e783c4dd-0e44-4768-b742-bcf04687f5fd.png" alt="image.png"><br><a name="P0boz"></a></p><h1 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 执行任务的线程池private final Executor executor;private final AbstractExecutorService aes;&#x2F;&#x2F; 存放已完成任务的阻塞队列，默认使用 LinkedBlockingQueueprivate final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="fSK2S"></a></p><h1 id="核心内部类"><a href="#核心内部类" class="headerlink" title="核心内部类"></a>核心内部类</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 将任务FutureTask做了扩展，实现了FutureTask的done方法private class QueueingFuture extends FutureTask&lt;Void&gt; &#123;    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;        super(task, null);        this.task &#x3D; task;    &#125;    &#x2F;&#x2F; 当任务完成后会回调这个方法，这时我们在这个方法中将完成的任务放到队列中，    &#x2F;&#x2F; 就实现了按照异步任务完成的顺序，逐个处理任务的结果了。    protected void done() &#123; completionQueue.add(task); &#125;    private final Future&lt;V&gt; task;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="sg1GV"></a></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>在构造函数中我们至少需要传入一个<code>Executor</code>线程池的实现来执行异步任务，但是建议再传入一个阻塞队列，默认的<code>LinkedBlockingQueue</code>是一个无界队列，有内存溢出的风险。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ExecutorCompletionService(Executor executor) &#123;    if (executor &#x3D;&#x3D; null)        throw new NullPointerException();    this.executor &#x3D; executor;    &#x2F;&#x2F; 自定义executor没有继承AbstractExecutorService，aes就为null    this.aes &#x3D; (executor instanceof AbstractExecutorService) ?        (AbstractExecutorService) executor : null;    &#x2F;&#x2F; 构造没有指定的话，默认使用一个无界阻塞队列    this.completionQueue &#x3D; new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();&#125;public ExecutorCompletionService(Executor executor,                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123;    if (executor &#x3D;&#x3D; null || completionQueue &#x3D;&#x3D; null)        throw new NullPointerException();    this.executor &#x3D; executor;    this.aes &#x3D; (executor instanceof AbstractExecutorService) ?        (AbstractExecutorService) executor : null;    this.completionQueue &#x3D; completionQueue;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="P7Lgm"></a></p><h1 id="submit提交任务"><a href="#submit提交任务" class="headerlink" title="submit提交任务"></a>submit提交任务</h1><p>提交任务前将task封装为<code>QueueingFuture</code>，当任务执行完成后就会回调<code>done</code>方法，放入任务队列中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 提交 Callable 任务public Future&lt;V&gt; submit(Callable&lt;V&gt; task) &#123;    if (task &#x3D;&#x3D; null) throw new NullPointerException();    &#x2F;&#x2F; 封装为 QueueingFuture    RunnableFuture&lt;V&gt; f &#x3D; newTaskFor(task);    executor.execute(new QueueingFuture(f));    return f;&#125;&#x2F;&#x2F; 提交 Runnable 任务，带返回结果public Future&lt;V&gt; submit(Runnable task, V result) &#123;    if (task &#x3D;&#x3D; null) throw new NullPointerException();    &#x2F;&#x2F; 封装为 QueueingFuture    RunnableFuture&lt;V&gt; f &#x3D; newTaskFor(task, result);    executor.execute(new QueueingFuture(f));    return f;&#125;private RunnableFuture&lt;V&gt; newTaskFor(Callable&lt;V&gt; task) &#123;    if (aes &#x3D;&#x3D; null)        return new FutureTask&lt;V&gt;(task);    else        return aes.newTaskFor(task);&#125;private RunnableFuture&lt;V&gt; newTaskFor(Runnable task, V result) &#123;    &#x2F;&#x2F; 如果是自定义Executor的话，默认使用FutureTask    if (aes &#x3D;&#x3D; null)        return new FutureTask&lt;V&gt;(task, result);    else        return aes.newTaskFor(task, result);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a name="HvyHn"></a></p><h1 id="获取已完成的任务"><a href="#获取已完成的任务" class="headerlink" title="获取已完成的任务"></a>获取已完成的任务</h1><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 如果没有任务，一直阻塞，直到有新任务进来public Future&lt;V&gt; take() throws InterruptedException &#123;    return completionQueue.take();&#125;&#x2F;&#x2F; 如果没有任务返回nullpublic Future&lt;V&gt; poll() &#123;    return completionQueue.poll();&#125;&#x2F;&#x2F; timeout时间内获取任务，没有返回nullpublic Future&lt;V&gt; poll(long timeout, TimeUnit unit)    throws InterruptedException &#123;    return completionQueue.poll(timeout, unit);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/11/05/hello-world/"/>
      <url>/2021/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
